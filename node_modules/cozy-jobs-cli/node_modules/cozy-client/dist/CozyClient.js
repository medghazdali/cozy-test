"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _toArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toArray"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _objectSpread2 = _interopRequireDefault(require("@babel/runtime/helpers/objectSpread"));

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _const = require("./const");

var _StackLink = _interopRequireDefault(require("./StackLink"));

var _associations = require("./associations");

var _helpers = require("./associations/helpers");

var _helpers2 = require("./helpers");

var _dsl = require("./queries/dsl");

var _cozyStackClient = _interopRequireWildcard(require("cozy-stack-client"));

var _mobile = require("./authentication/mobile");

var _optimize = _interopRequireDefault(require("./queries/optimize"));

var _store = _interopRequireWildcard(require("./store"));

var _policies = _interopRequireDefault(require("./policies"));

var _Schema = _interopRequireDefault(require("./Schema"));

var _CozyLink = require("./CozyLink");

var _ObservableQuery = _interopRequireDefault(require("./ObservableQuery"));

var _mapValues = _interopRequireDefault(require("lodash/mapValues"));

var _fromPairs = _interopRequireDefault(require("lodash/fromPairs"));

var _flatten = _interopRequireDefault(require("lodash/flatten"));

var _uniqBy = _interopRequireDefault(require("lodash/uniqBy"));

var _zip = _interopRequireDefault(require("lodash/zip"));

var _forEach = _interopRequireDefault(require("lodash/forEach"));

var _get = _interopRequireDefault(require("lodash/get"));

var _microee = _interopRequireDefault(require("microee"));

var _snapshots = require("./testing/snapshots");

var ensureArray = function ensureArray(arr) {
  return Array.isArray(arr) ? arr : [arr];
};

var deprecatedHandler = function deprecatedHandler(msg) {
  return {
    get: function get(target, prop) {
      console.warn(msg);
      return target[prop];
    }
  };
};
/**
 * @typedef {object} Link
 * @typedef {object} Mutation
 * @typedef {object} DocumentCollection
 * @typedef {object} QueryResult
 * @typedef {object} HydratedDocument
 * @typedef {object} ReduxStore
 * @typedef {object} QueryState
 */


var TRIGGER_CREATION = 'creation';
var TRIGGER_UPDATE = 'update';
/**
 * Responsible for
 *
 * - Creating observable queries
 * - Hydration
 * - Creating plan for saving documents
 * - Associations
 */

var CozyClient =
/*#__PURE__*/
function () {
  /**
   * @param  {object}       options - Options
   * @param  {Link}         options.link   - Backward compatibility
   * @param  {Array.Link}   options.links  - List of links
   * @param  {object}       options.schema - Schema description for each doctypes
   * @param  {object}       options.appMetadata - Metadata about the application that will be used in ensureCozyMetadata
   *
   * Cozy-Client will automatically call `this.login()` if provided with a token and an uri
   */
  function CozyClient() {
    var _this = this;

    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    var link = _ref.link,
        links = _ref.links,
        _ref$schema = _ref.schema,
        schema = _ref$schema === void 0 ? {} : _ref$schema,
        _ref$appMetadata = _ref.appMetadata,
        appMetadata = _ref$appMetadata === void 0 ? {} : _ref$appMetadata,
        options = (0, _objectWithoutProperties2.default)(_ref, ["link", "links", "schema", "appMetadata"]);
    (0, _classCallCheck2.default)(this, CozyClient);

    if (link) {
      console.warn('`link` is deprecated, use `links`');
    }

    this.appMetadata = appMetadata;
    this.options = options;
    this.idCounter = 1;
    this.isLogged = false;
    this.instanceOptions = {}; // Bind handlers

    this.handleRevocationChange = this.handleRevocationChange.bind(this);
    this.handleTokenRefresh = this.handleTokenRefresh.bind(this);
    this.createClient();
    var stackClient = this.getStackClient();
    stackClient.on('error', function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _this.emit.apply(_this, ['error'].concat(args));
    });
    this.links = ensureArray(link || links || new _StackLink.default());
    this.registerClientOnLinks();
    this.chain = (0, _CozyLink.chain)(this.links);
    this.schema = new _Schema.default(schema, stackClient); // Instances of plugins registered with registerPlugin

    this.plugins = {};

    try {
      this.loadInstanceOptionsFromDOM();
    } catch (err) {// not a critical error, we may be in node or the instance options are not on the default HTML element
    }

    if (options.uri && options.token) {
      this.login();
    }
  }
  /**
   * A plugin is a class whose constructor receives the client as first argument.
   * The main mean of interaction with the client should be with events
   * like "login"/"logout".
   *
   * The plugin system is meant to encourage separation of concerns, modularity
   * and testability : instead of registering events at module level, please
   * create a plugin that subscribes to events.
   *
   * Plugin instances are stored internally in the `plugins` attribute of the client
   * and can be accessed via this mean. A plugin class must have the attribute
   * `pluginName` that will be use as the key in the `plugins` object.
   *
   * Two plugins with the same `pluginName` cannot co-exist.
   *
   * @example
   * ```
   * class AlertPlugin {
   *   constructor(client, options) {
   *     this.client = client
   *     this.options = options
   *     this.handleLogin = this.handleLogin.bind(this)
   *     this.handleLogout = this.handleLogout.bind(this)
   *     this.client.on("login", this.handleLogin)
   *     this.client.on("logout", this.handleLogout)
   *   }
   *
   *   handleLogin() {
   *     alert(this.options.onLoginAlert)
   *   }
   *
   *   handleLogout() {
   *     alert(this.options.onLogoutAlert)
   *   }
   * }
   *
   * AlertPlugin.pluginName = 'alerts'
   *
   * client.registerPlugin(AlertPlugin, {
   *   onLoginAlert: 'client has logged in !',
   *   onLogoutAlert: 'client has logged out !'
   * })
   *
   * // the instance of the plugin is accessible via
   * client.plugins.alerts
   * ```
   */


  (0, _createClass2.default)(CozyClient, [{
    key: "registerPlugin",
    value: function registerPlugin(Plugin, options) {
      if (!Plugin.pluginName) {
        throw new Error('Cannot register a plugin whose class does not have `pluginName` attribute.');
      }

      if (this.plugins[Plugin.pluginName]) {
        throw new Error("Cannot register plugin ".concat(Plugin.pluginName, ". A plugin with the same name has already been registered."));
      }

      var instance = new Plugin(this, options);
      this.plugins[Plugin.pluginName] = instance;
      return instance;
    }
    /**
     * To help with the transition from cozy-client-js to cozy-client, it is possible to instantiate
     * a client with a cookie-based instance of cozy-client-js.
     */

  }, {
    key: "addSchema",
    value: function addSchema(schemaDefinition) {
      this.schema.add(schemaDefinition);
    }
  }, {
    key: "registerClientOnLinks",
    value: function registerClientOnLinks() {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this.links[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var link = _step.value;

          if (link.registerClient) {
            try {
              link.registerClient(this);
            } catch (e) {
              console.warn(e);
            }
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
    /**
     * Notify the links that they can start and set isLogged to true.
     *
     * On mobile, where url/token are set after instantiation, use this method
     * to set the token and uri via options.
     *
     * Emits
     *
     * - "beforeLogin" at the beginning, before links have been set up
     * - "login" when the client is fully logged in and links have been set up
     *
     * @param  {object}   options - Options
     * @param  {string}   options.token  - If passed, the token is set on the client
     * @param  {string}   options.uri  - If passed, the uri is set on the client
     * @returns {Promise} - Resolves when all links have been setup and client is fully logged in
     *
     */

  }, {
    key: "login",
    value: function login(options) {
      // Keep the promise to be able to return it in future calls.
      // This allows us to autoLogin in constructor without breaking any compatibility
      // with codes that uses an explicit login.
      if (this.isLogged && !this.isRevoked) {
        console.warn("CozyClient is already logged.");
        return this.loginPromise;
      }

      return this.loginPromise = this._login(options);
    }
  }, {
    key: "_login",
    value: function () {
      var _login2 = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee(options) {
        var _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, link;

        return _regenerator.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                this.emit('beforeLogin');
                this.registerClientOnLinks();

                if (options) {
                  if (options.uri) {
                    this.stackClient.setUri(options.uri);
                  }

                  if (options.token) {
                    this.stackClient.setToken(options.token);
                  }
                }

                _iteratorNormalCompletion2 = true;
                _didIteratorError2 = false;
                _iteratorError2 = undefined;
                _context.prev = 6;
                _iterator2 = this.links[Symbol.iterator]();

              case 8:
                if (_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done) {
                  _context.next = 16;
                  break;
                }

                link = _step2.value;

                if (!link.onLogin) {
                  _context.next = 13;
                  break;
                }

                _context.next = 13;
                return link.onLogin();

              case 13:
                _iteratorNormalCompletion2 = true;
                _context.next = 8;
                break;

              case 16:
                _context.next = 22;
                break;

              case 18:
                _context.prev = 18;
                _context.t0 = _context["catch"](6);
                _didIteratorError2 = true;
                _iteratorError2 = _context.t0;

              case 22:
                _context.prev = 22;
                _context.prev = 23;

                if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
                  _iterator2.return();
                }

              case 25:
                _context.prev = 25;

                if (!_didIteratorError2) {
                  _context.next = 28;
                  break;
                }

                throw _iteratorError2;

              case 28:
                return _context.finish(25);

              case 29:
                return _context.finish(22);

              case 30:
                this.isLogged = true;
                this.isRevoked = false;
                this.emit('login');

              case 33:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[6, 18, 22, 30], [23,, 25, 29]]);
      }));

      return function _login(_x) {
        return _login2.apply(this, arguments);
      };
    }()
    /**
     * Logs out the client and reset all the links
     *
     * Emits
     *
     * - "beforeLogout" at the beginning, before links have been reset
     * - "login" when the client is fully logged out and links have been reset
     *
     * @returns {Promise} - Resolves when all links have been reset and client is fully logged out
     */

  }, {
    key: "logout",
    value: function () {
      var _logout = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee2() {
        var _iteratorNormalCompletion3, _didIteratorError3, _iteratorError3, _iterator3, _step3, link;

        return _regenerator.default.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (this.isLogged) {
                  _context2.next = 3;
                  break;
                }

                console.warn("CozyClient isn't logged.");
                return _context2.abrupt("return");

              case 3:
                this.emit('beforeLogout');
                this.isLogged = false;

                if (!(this.stackClient instanceof _cozyStackClient.OAuthClient)) {
                  _context2.next = 17;
                  break;
                }

                _context2.prev = 6;

                if (!(this.stackClient.unregister && (!this.stackClient.isRegistered || this.stackClient.isRegistered()))) {
                  _context2.next = 10;
                  break;
                }

                _context2.next = 10;
                return this.stackClient.unregister();

              case 10:
                _context2.next = 15;
                break;

              case 12:
                _context2.prev = 12;
                _context2.t0 = _context2["catch"](6);
                console.warn("Impossible to unregister client on stack: ".concat(_context2.t0));

              case 15:
                _context2.next = 25;
                break;

              case 17:
                _context2.prev = 17;
                _context2.next = 20;
                return this.stackClient.fetch('DELETE', '/auth/login');

              case 20:
                _context2.next = 25;
                break;

              case 22:
                _context2.prev = 22;
                _context2.t1 = _context2["catch"](17);
                console.warn("Impossible to log out: ".concat(_context2.t1));

              case 25:
                // clean information on links
                _iteratorNormalCompletion3 = true;
                _didIteratorError3 = false;
                _iteratorError3 = undefined;
                _context2.prev = 28;
                _iterator3 = this.links[Symbol.iterator]();

              case 30:
                if (_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done) {
                  _context2.next = 44;
                  break;
                }

                link = _step3.value;

                if (!link.reset) {
                  _context2.next = 41;
                  break;
                }

                _context2.prev = 33;
                _context2.next = 36;
                return link.reset();

              case 36:
                _context2.next = 41;
                break;

              case 38:
                _context2.prev = 38;
                _context2.t2 = _context2["catch"](33);
                console.warn(_context2.t2);

              case 41:
                _iteratorNormalCompletion3 = true;
                _context2.next = 30;
                break;

              case 44:
                _context2.next = 50;
                break;

              case 46:
                _context2.prev = 46;
                _context2.t3 = _context2["catch"](28);
                _didIteratorError3 = true;
                _iteratorError3 = _context2.t3;

              case 50:
                _context2.prev = 50;
                _context2.prev = 51;

                if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
                  _iterator3.return();
                }

              case 53:
                _context2.prev = 53;

                if (!_didIteratorError3) {
                  _context2.next = 56;
                  break;
                }

                throw _iteratorError3;

              case 56:
                return _context2.finish(53);

              case 57:
                return _context2.finish(50);

              case 58:
                if (this.store) {
                  this.dispatch((0, _store.resetState)());
                }

                this.emit('logout');

              case 60:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this, [[6, 12], [17, 22], [28, 46, 50, 58], [33, 38], [51,, 53, 57]]);
      }));

      return function logout() {
        return _logout.apply(this, arguments);
      };
    }()
    /**
     * Forwards to a stack client instance and returns
     * a [DocumentCollection]{@link https://docs.cozy.io/en/cozy-client/api/cozy-stack-client/#DocumentCollection} instance.
     *
     * @param  {string} doctype The collection doctype.
     * @returns {DocumentCollection} Collection corresponding to the doctype
     */

  }, {
    key: "collection",
    value: function collection(doctype) {
      return this.getStackClient().collection(doctype);
    }
  }, {
    key: "fetch",
    value: function fetch(method, path, body) {
      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
      return this.getStackClient().fetch(method, path, body, options);
    }
  }, {
    key: "all",
    value: function all(doctype) {
      console.warn("\nclient.all is deprecated, prefer to use the Q helper to build a new QueryDefinition.\n\nimport { Q } from 'cozy-client'\nclient.query(Q('io.cozy.bills'))");
      return (0, _dsl.Q)(doctype);
    }
  }, {
    key: "find",
    value: function find(doctype) {
      var selector = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
      return new _dsl.QueryDefinition({
        doctype: doctype,
        selector: selector
      });
    }
  }, {
    key: "get",
    value: function get(doctype, id) {
      return new _dsl.QueryDefinition({
        doctype: doctype,
        id: id
      });
    }
  }, {
    key: "create",
    value: function () {
      var _create = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee3(type, _ref2, relationships) {
        var options,
            _type,
            attributes,
            document,
            ret,
            _args3 = arguments;

        return _regenerator.default.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                options = _args3.length > 3 && _args3[3] !== undefined ? _args3[3] : {};
                _type = _ref2._type, attributes = (0, _objectWithoutProperties2.default)(_ref2, ["_type"]);
                document = (0, _objectSpread2.default)({
                  _type: type
                }, attributes);
                _context3.next = 5;
                return this.schema.validate(document);

              case 5:
                ret = _context3.sent;

                if (!(ret !== true)) {
                  _context3.next = 8;
                  break;
                }

                throw new Error('Validation failed');

              case 8:
                return _context3.abrupt("return", this.mutate(this.getDocumentSavePlan(document, relationships), options));

              case 9:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      return function create(_x2, _x3, _x4) {
        return _create.apply(this, arguments);
      };
    }()
  }, {
    key: "validate",
    value: function validate(document) {
      return this.schema.validate(document);
    }
  }, {
    key: "save",
    value: function () {
      var _save = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee4(document) {
        var mutationOptions,
            ret,
            _args4 = arguments;
        return _regenerator.default.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                mutationOptions = _args4.length > 1 && _args4[1] !== undefined ? _args4[1] : {};
                _context4.next = 3;
                return this.schema.validate(document);

              case 3:
                ret = _context4.sent;

                if (!(ret !== true)) {
                  _context4.next = 6;
                  break;
                }

                throw new Error('Validation failed');

              case 6:
                return _context4.abrupt("return", this.mutate(this.getDocumentSavePlan(document), mutationOptions));

              case 7:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      return function save(_x5) {
        return _save.apply(this, arguments);
      };
    }()
  }, {
    key: "ensureCozyMetadata",
    value: function ensureCozyMetadata(document) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
        event: TRIGGER_CREATION
      };
      var METADATA_VERSION = 1;
      if (this.appMetadata === undefined) return document;
      var doctypeVersion;

      if (document._type) {
        var schema = this.schema.getDoctypeSchema(document._type);
        doctypeVersion = (0, _get.default)(schema, 'doctypeVersion');
      }

      var _this$appMetadata = this.appMetadata,
          slug = _this$appMetadata.slug,
          sourceAccount = _this$appMetadata.sourceAccount,
          version = _this$appMetadata.version;
      var now = new Date().toISOString();
      var cozyMetadata = (0, _get.default)(document, 'cozyMetadata', {});

      if (options.event === TRIGGER_CREATION) {
        cozyMetadata = (0, _objectSpread2.default)({
          metadataVersion: METADATA_VERSION,
          doctypeVersion: doctypeVersion,
          createdByApp: slug,
          sourceAccount: sourceAccount,
          createdAt: now,
          createdByAppVersion: version,
          updatedAt: now,
          updatedByApps: slug ? [{
            date: now,
            slug: slug,
            version: version
          }] : []
        }, cozyMetadata);
      } else if (options.event === TRIGGER_UPDATE) {
        cozyMetadata = (0, _objectSpread2.default)({}, cozyMetadata, {
          updatedAt: now,
          updatedByApps: [{
            date: now,
            slug: slug,
            version: version
          }].concat((0, _toConsumableArray2.default)((0, _get.default)(document, 'cozyMetadata.updatedByApps', []).filter(function (info) {
            return info.slug !== slug;
          })))
        });
      }

      return (0, _objectSpread2.default)({}, document, {
        cozyMetadata: cozyMetadata
      });
    }
    /**
     * Creates a list of mutations to execute to create a document and its relationships.
     *
     * ```js
     * const baseDoc = { _type: 'io.cozy.todo', label: 'Go hiking' }
     * // relations can be arrays or single objects
     * const relationships = {
     *   attachments: [{ _id: 12345, _type: 'io.cozy.files' }, { _id: 6789, _type: 'io.cozy.files' }],
     *   bills: { _id: 9999, _type: 'io.cozy.bills' }
     * }
     * client.getDocumentSavePlan(baseDoc, relationships)
     * ```
     *
     * @param  {object} document      The base document to create
     * @param  {object} relationships The list of relationships to add, as a dictionnary. Keys should be relationship names and values the documents to link.
     * @returns {Mutation[]}  One or more mutation to execute
     */

  }, {
    key: "getDocumentSavePlan",
    value: function getDocumentSavePlan(document, relationships) {
      var _this2 = this;

      var newDocument = !document._rev;
      var dehydratedDoc = this.ensureCozyMetadata((0, _helpers2.dehydrate)(document), {
        event: newDocument ? TRIGGER_CREATION : TRIGGER_UPDATE
      });
      var saveMutation = newDocument ? _dsl.Mutations.createDocument(dehydratedDoc) : _dsl.Mutations.updateDocument(dehydratedDoc);
      var hasRelationships = relationships && Object.values(relationships).filter(function (relations) {
        return Array.isArray(relations) ? relations.length > 0 : relations;
      }).length > 0;

      if (!hasRelationships) {
        return saveMutation;
      }

      if (relationships && !newDocument) {
        throw new Error('Unable to save relationships on a not-new document');
      }

      return [saveMutation, function (response) {
        var document = _this2.hydrateDocument(response.data);

        return Object.keys(relationships).map(function (name) {
          var val = relationships[name];
          return Array.isArray(val) ? document[name].insertDocuments(val) : document[name].setDocument(val);
        });
      }];
    }
    /**
     * Hooks are an observable system for events on documents.
     * There are at the moment only 2 hooks available.
     *
     * - before:destroy, called just before a document is destroyed via CozyClient::destroy
     * - after:destroy, called after a document is destroyed via CozyClient::destroy
     *
     * @example
     * ```
     * CozyClient.registerHook('io.cozy.bank.accounts', 'before:destroy', () => {
     *   console.log('A io.cozy.bank.accounts is being destroyed')
     * })
     * ```
     *
     * @param  {string}   doctype - Doctype on which the hook will be registered
     * @param  {string}   name    - Name of the hook
     * @param  {Function} fn      - Callback to be executed
     */

  }, {
    key: "triggerHook",
    value: function triggerHook(name, document) {
      if (!CozyClient.hooks) return;
      var allHooks = CozyClient.hooks[document._type] || {};
      var hooks = allHooks[name] || [];
      var _iteratorNormalCompletion4 = true;
      var _didIteratorError4 = false;
      var _iteratorError4 = undefined;

      try {
        for (var _iterator4 = hooks[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          var h = _step4.value;
          h(this, document);
        }
      } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion4 && _iterator4.return != null) {
            _iterator4.return();
          }
        } finally {
          if (_didIteratorError4) {
            throw _iteratorError4;
          }
        }
      }
    }
    /**
     * Destroys a document. {before,after}:destroy hooks will be fired.
     *
     * @param  {Document} document - Document to be deleted
     * @returns {Document} The document that has been deleted
     */

  }, {
    key: "destroy",
    value: function () {
      var _destroy = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee5(document) {
        var mutationOptions,
            res,
            _args5 = arguments;
        return _regenerator.default.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                mutationOptions = _args5.length > 1 && _args5[1] !== undefined ? _args5[1] : {};
                _context5.next = 3;
                return this.triggerHook('before:destroy', document);

              case 3:
                _context5.next = 5;
                return this.mutate(_dsl.Mutations.deleteDocument(document), mutationOptions);

              case 5:
                res = _context5.sent;
                _context5.next = 8;
                return this.triggerHook('after:destroy', document);

              case 8:
                return _context5.abrupt("return", res);

              case 9:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      return function destroy(_x6) {
        return _destroy.apply(this, arguments);
      };
    }()
  }, {
    key: "upload",
    value: function upload(file, dirPath) {
      var mutationOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      return this.mutate(_dsl.Mutations.uploadFile(file, dirPath), mutationOptions);
    }
  }, {
    key: "ensureQueryExists",
    value: function ensureQueryExists(queryId, queryDefinition) {
      this.ensureStore();
      var existingQuery = (0, _store.getQueryFromState)(this.store.getState(), queryId); // Don't trigger the INIT_QUERY for fetchMore() calls

      if (existingQuery.fetchStatus !== 'loaded' || !queryDefinition.skip && !queryDefinition.bookmark) {
        this.dispatch((0, _store.initQuery)(queryId, queryDefinition));
      }
    }
    /**
     * Executes a query and returns its results.
     *
     * Results from the query will be saved internally and can be retrieved via
     * `getQueryFromState` or directly using `<Query />`. `<Query />` automatically
     * executes its query when mounted if no fetch policy has been indicated.
     *
     * @param  {QueryDefinition} queryDefinition - Definition that will be executed
     * @param  {string} options - Options
     * @param  {string} options.as - Names the query so it can be reused (by multiple components for example)
     * @param  {string} options.fetchPolicy - Fetch policy to bypass fetching based on what's already inside the state. See "Fetch policies"
     * @returns {QueryResult}
     */

  }, {
    key: "query",
    value: function () {
      var _query = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee6(queryDefinition) {
        var _ref3,
            update,
            options,
            queryId,
            existingQuery,
            shouldFetch,
            response,
            _args6 = arguments;

        return _regenerator.default.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                _ref3 = _args6.length > 1 && _args6[1] !== undefined ? _args6[1] : {};
                update = _ref3.update, options = (0, _objectWithoutProperties2.default)(_ref3, ["update"]);
                this.ensureStore();
                queryId = options.as || this.generateId();
                this.ensureQueryExists(queryId, queryDefinition);

                if (!options.fetchPolicy) {
                  _context6.next = 12;
                  break;
                }

                if (options.as) {
                  _context6.next = 8;
                  break;
                }

                throw new Error('Cannot use `fetchPolicy` without naming the query, please use `as` to name the query');

              case 8:
                existingQuery = this.getQueryFromState(queryId);
                shouldFetch = options.fetchPolicy(existingQuery);

                if (shouldFetch) {
                  _context6.next = 12;
                  break;
                }

                return _context6.abrupt("return");

              case 12:
                _context6.prev = 12;
                _context6.next = 15;
                return this.requestQuery(queryDefinition);

              case 15:
                response = _context6.sent;
                this.dispatch((0, _store.receiveQueryResult)(queryId, response, {
                  update: update
                }));
                return _context6.abrupt("return", response);

              case 20:
                _context6.prev = 20;
                _context6.t0 = _context6["catch"](12);
                this.dispatch((0, _store.receiveQueryError)(queryId, _context6.t0));
                throw _context6.t0;

              case 24:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this, [[12, 20]]);
      }));

      return function query(_x7) {
        return _query.apply(this, arguments);
      };
    }()
    /**
     * Will fetch all documents for a `queryDefinition`, automatically fetching more
     * documents if the total of documents is superior to the pagination limit. Can
     * result in a lot of network requests.
     *
     * @param  {QueryDefinition} queryDefinition - Definition to be executed
     * @param  {object} options - Options to the query
     * @returns {Array} All documents matching the query
     */

  }, {
    key: "queryAll",
    value: function () {
      var _queryAll = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee7(queryDefinition, options) {
        var documents, resp;
        return _regenerator.default.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                documents = [];
                resp = {
                  next: true
                };

              case 2:
                if (!(resp && resp.next)) {
                  _context7.next = 9;
                  break;
                }

                _context7.next = 5;
                return this.query(queryDefinition.offsetBookmark(resp.bookmark), options);

              case 5:
                resp = _context7.sent;
                documents.push.apply(documents, (0, _toConsumableArray2.default)(resp.data));
                _context7.next = 2;
                break;

              case 9:
                return _context7.abrupt("return", documents);

              case 10:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      return function queryAll(_x8, _x9) {
        return _queryAll.apply(this, arguments);
      };
    }()
  }, {
    key: "watchQuery",
    value: function watchQuery() {
      console.warn('client.watchQuery is deprecated, please use client.makeObservableQuery.');
      return this.makeObservableQuery.apply(this, arguments);
    }
  }, {
    key: "makeObservableQuery",
    value: function makeObservableQuery(queryDefinition) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      this.ensureStore();
      var queryId = options.as || this.generateId();
      this.ensureQueryExists(queryId, queryDefinition);
      return new _ObservableQuery.default(queryId, queryDefinition, this);
    }
  }, {
    key: "mutate",
    value: function () {
      var _mutate = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee8(mutationDefinition) {
        var _ref4,
            update,
            updateQueries,
            options,
            mutationId,
            response,
            _args8 = arguments;

        return _regenerator.default.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                _ref4 = _args8.length > 1 && _args8[1] !== undefined ? _args8[1] : {};
                update = _ref4.update, updateQueries = _ref4.updateQueries, options = (0, _objectWithoutProperties2.default)(_ref4, ["update", "updateQueries"]);
                this.ensureStore();
                mutationId = options.as || this.generateId();
                this.dispatch((0, _store.initMutation)(mutationId, mutationDefinition));
                _context8.prev = 5;
                _context8.next = 8;
                return this.requestMutation(mutationDefinition);

              case 8:
                response = _context8.sent;
                this.dispatch((0, _store.receiveMutationResult)(mutationId, response, {
                  update: update,
                  updateQueries: updateQueries
                }, mutationDefinition));
                return _context8.abrupt("return", response);

              case 13:
                _context8.prev = 13;
                _context8.t0 = _context8["catch"](5);
                this.dispatch((0, _store.receiveMutationError)(mutationId, _context8.t0, mutationDefinition));
                throw _context8.t0;

              case 17:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this, [[5, 13]]);
      }));

      return function mutate(_x10) {
        return _mutate.apply(this, arguments);
      };
    }()
    /**
     * Executes a query through links and fetches relationships
     *
     * @private
     * @param  {QueryDefinition} definition QueryDefinition to be executed
     * @returns {Response}
     */

  }, {
    key: "requestQuery",
    value: function () {
      var _requestQuery = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee9(definition) {
        var mainResponse, withIncluded;
        return _regenerator.default.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                _context9.next = 2;
                return this.chain.request(definition);

              case 2:
                mainResponse = _context9.sent;

                if (definition.includes) {
                  _context9.next = 5;
                  break;
                }

                return _context9.abrupt("return", mainResponse);

              case 5:
                _context9.next = 7;
                return this.fetchRelationships(mainResponse, this.getIncludesRelationships(definition));

              case 7:
                withIncluded = _context9.sent;
                return _context9.abrupt("return", withIncluded);

              case 9:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      return function requestQuery(_x11) {
        return _requestQuery.apply(this, arguments);
      };
    }()
    /**
     * Fetch relationships for a response (can be several docs).
     * Fills the `relationships` attribute of each documents.
     *
     * Can potentially result in several fetch requests.
     * Queries are optimized before being sent (multiple single documents queries can be packed into
     * one multiple document query) for example.
     *
     * @private
     */

  }, {
    key: "fetchRelationships",
    value: function () {
      var _fetchRelationships = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee10(response, relationshipsByName) {
        var _this3 = this;

        var isSingleDoc, responseDocs, queryDefToDocIdAndRel, documents, definitions, optimizedDefinitions, responses, uniqueDocuments, included, relationshipsByDocId, _iteratorNormalCompletion5, _didIteratorError5, _iteratorError5, _iterator5, _step5, _step5$value, def, resp, docIdAndRel, _docIdAndRel, docId, relName;

        return _regenerator.default.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                isSingleDoc = !Array.isArray(response.data);

                if (!(!isSingleDoc && response.data.length === 0)) {
                  _context10.next = 3;
                  break;
                }

                return _context10.abrupt("return", response);

              case 3:
                responseDocs = isSingleDoc ? [response.data] : response.data;
                queryDefToDocIdAndRel = new Map();
                documents = [];
                definitions = [];
                responseDocs.forEach(function (doc) {
                  return (0, _forEach.default)(relationshipsByName, function (relationship, relName) {
                    try {
                      var queryDef = relationship.type.query(doc, _this3, relationship);
                      var docId = doc._id; // Used to reattach responses into the relationships attribute of
                      // each document

                      queryDefToDocIdAndRel.set(queryDef, [docId, relName]); // Relationships can yield "queries" that are already resolved documents.
                      // These do not need to go through the usual link request mechanism.

                      if (queryDef instanceof _dsl.QueryDefinition) {
                        definitions.push(queryDef);
                      } else {
                        documents.push(queryDef);
                      }
                    } catch (_unused) {// eslint-disable-next-line
                      // We do not crash completely if one the relationship behaves badly and
                      // throws
                    }
                  });
                }); // Definitions can be in optimized/regrouped in case of HasMany relationships.

                optimizedDefinitions = (0, _optimize.default)(definitions);
                _context10.next = 11;
                return Promise.all(optimizedDefinitions.map(function (req) {
                  return _this3.chain.request(req);
                }));

              case 11:
                responses = _context10.sent;
                // "Included" documents will be stored in the `documents` store
                uniqueDocuments = (0, _uniqBy.default)((0, _flatten.default)(documents), '_id');
                included = (0, _flatten.default)(responses.map(function (r) {
                  return r.included || r.data;
                })).concat(uniqueDocuments).filter(Boolean); // Some relationships have the relationship data on the other side of the
                // relationship (ex: io.cozy.photos.albums do not have photo inclusion information,
                // it is on the io.cozy.files side).
                // Here we take the data received from the relationship queries, and group
                // it so that we can fill the `relationships` attribute of each doc before
                // storing the document. This makes the data easier to manipulate for the front-end.

                relationshipsByDocId = {};
                _iteratorNormalCompletion5 = true;
                _didIteratorError5 = false;
                _iteratorError5 = undefined;
                _context10.prev = 18;

                for (_iterator5 = (0, _zip.default)(optimizedDefinitions, responses)[Symbol.iterator](); !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
                  _step5$value = (0, _slicedToArray2.default)(_step5.value, 2), def = _step5$value[0], resp = _step5$value[1];
                  docIdAndRel = queryDefToDocIdAndRel.get(def);

                  if (docIdAndRel) {
                    _docIdAndRel = (0, _slicedToArray2.default)(docIdAndRel, 2), docId = _docIdAndRel[0], relName = _docIdAndRel[1];
                    relationshipsByDocId[docId] = relationshipsByDocId[docId] || {};
                    relationshipsByDocId[docId][relName] = (0, _helpers.responseToRelationship)(resp);
                  }
                }

                _context10.next = 26;
                break;

              case 22:
                _context10.prev = 22;
                _context10.t0 = _context10["catch"](18);
                _didIteratorError5 = true;
                _iteratorError5 = _context10.t0;

              case 26:
                _context10.prev = 26;
                _context10.prev = 27;

                if (!_iteratorNormalCompletion5 && _iterator5.return != null) {
                  _iterator5.return();
                }

              case 29:
                _context10.prev = 29;

                if (!_didIteratorError5) {
                  _context10.next = 32;
                  break;
                }

                throw _iteratorError5;

              case 32:
                return _context10.finish(29);

              case 33:
                return _context10.finish(26);

              case 34:
                return _context10.abrupt("return", (0, _objectSpread2.default)({}, (0, _helpers.attachRelationships)(response, relationshipsByDocId), {
                  included: included
                }));

              case 35:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, null, [[18, 22, 26, 34], [27,, 29, 33]]);
      }));

      return function fetchRelationships(_x12, _x13) {
        return _fetchRelationships.apply(this, arguments);
      };
    }()
  }, {
    key: "requestMutation",
    value: function () {
      var _requestMutation = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee11(definition) {
        var _this4 = this;

        var _definition, first, rest, firstResponse;

        return _regenerator.default.wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                if (!Array.isArray(definition)) {
                  _context11.next = 8;
                  break;
                }

                _definition = (0, _toArray2.default)(definition), first = _definition[0], rest = _definition.slice(1);
                _context11.next = 4;
                return this.requestMutation(first);

              case 4:
                firstResponse = _context11.sent;
                _context11.next = 7;
                return Promise.all(rest.map(function (def) {
                  return typeof def === 'function' ? _this4.requestMutation(def(firstResponse)) : _this4.requestMutation(def);
                }));

              case 7:
                return _context11.abrupt("return", firstResponse);

              case 8:
                return _context11.abrupt("return", this.chain.request(definition));

              case 9:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      return function requestMutation(_x14) {
        return _requestMutation.apply(this, arguments);
      };
    }()
  }, {
    key: "getIncludesRelationships",
    value: function getIncludesRelationships(queryDefinition) {
      var _this5 = this;

      var includes = queryDefinition.includes,
          doctype = queryDefinition.doctype;
      if (!includes) return {};
      return (0, _fromPairs.default)(includes.map(function (relName) {
        return [relName, _this5.schema.getRelationship(doctype, relName)];
      }));
    }
    /**
     * Returns documents with their relationships resolved according to their schema.
     * If related documents are not in the store, they will not be fetched automatically.
     * Instead, the relationships will have null documents.
     *
     * @param  {string} doctype
     * @param  {Array<Document>} documents
     * @returns {Array<HydratedDocument>}
     */

  }, {
    key: "hydrateDocuments",
    value: function hydrateDocuments(doctype, documents) {
      var _this6 = this;

      if (this.options.autoHydrate === false) {
        return documents;
      }

      var schema = this.schema.getDoctypeSchema(doctype);
      var relationships = schema.relationships;

      if (relationships) {
        return documents.map(function (doc) {
          return _this6.hydrateDocument(doc, schema);
        });
      } else {
        return documents;
      }
    }
    /**
     * Resolves relationships on a document.
     *
     * The original document is kept in the target attribute of
     * the relationship
     *
     * @param  {Document} document for which relationships must be resolved
     * @param  {Schema} schema for the document doctype
     * @returns {HydratedDocument}
     */

  }, {
    key: "hydrateDocument",
    value: function hydrateDocument(document, schema) {
      if (!document) {
        return document;
      }

      schema = schema || this.schema.getDoctypeSchema(document._type);
      return (0, _objectSpread2.default)({}, document, this.hydrateRelationships(document, schema.relationships));
    }
  }, {
    key: "hydrateRelationships",
    value: function hydrateRelationships(document, schemaRelationships) {
      var methods = this.getRelationshipStoreAccessors();
      return (0, _mapValues.default)(schemaRelationships, function (assoc, name) {
        return (0, _associations.create)(document, assoc, methods);
      });
    }
    /**
     * Creates (locally) a new document for the given doctype.
     * This document is hydrated : its relationships are there
     * and working.
     */

  }, {
    key: "makeNewDocument",
    value: function makeNewDocument(doctype) {
      var obj = {
        _type: doctype
      };
      return this.hydrateDocument(obj);
    }
    /**
     * Creates an association that is linked to the store.
     */

  }, {
    key: "getAssociation",
    value: function getAssociation(document, associationName) {
      return (0, _associations.create)(document, this.schema.getAssociation(document._type, associationName), this.getRelationshipStoreAccessors());
    }
    /**
     * Returns the accessors that are given to the relationships for them
     * to deal with the stores.
     *
     * Relationships need to have access to the store to ping it when
     * a modification (addById/removeById etc...) has been done. This wakes
     * the store up, which in turn will update the `<Query>`s and re-render the data.
     */

  }, {
    key: "getRelationshipStoreAccessors",
    value: function getRelationshipStoreAccessors() {
      var _this7 = this;

      if (!this.storeAccesors) {
        this.storeAccessors = {
          get: this.getDocumentFromState.bind(this),
          save: function save(document, opts) {
            return _this7.save.call(_this7, document, opts);
          },
          dispatch: this.dispatch.bind(this),
          query: function query(def, opts) {
            return _this7.query.call(_this7, def, opts);
          },
          mutate: function mutate(def, opts) {
            return _this7.mutate.call(_this7, def, opts);
          }
        };
      }

      return this.storeAccessors;
    }
    /**
     * Get a collection of documents from the internal store.
     *
     * @param {string} type - Doctype of the collection
     *
     * @returns {Document[]} Array of documents or null if the collection does not exist.
     */

  }, {
    key: "getCollectionFromState",
    value: function getCollectionFromState(type) {
      try {
        return (0, _store.getCollectionFromState)(this.store.getState(), type);
      } catch (e) {
        console.warn('Could not getCollectionFromState', type, e.message);
        return null;
      }
    }
    /**
     * Get a document from the internal store.
     *
     * @param {string} type - Doctype of the document
     * @param {string} id   - Id of the document
     *
     * @returns {Document} Document or null if the object does not exist.
     */

  }, {
    key: "getDocumentFromState",
    value: function getDocumentFromState(type, id) {
      try {
        return (0, _store.getDocumentFromState)(this.store.getState(), type, id);
      } catch (e) {
        console.warn('Could not getDocumentFromState', type, id, e.message);
        return null;
      }
    }
    /**
     * Get a query from the internal store.
     *
     * @param {string} id - Id of the query (set via Query.props.as)
     * @param {object} options - Options
     * @param {boolean} options.hydrated - Whether documents should be returned already hydrated (default: false)
     *
     * @returns {QueryState} - Query state or null if it does not exist.
     */

  }, {
    key: "getQueryFromState",
    value: function getQueryFromState(id) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var hydrated = options.hydrated || false;

      try {
        var queryResults = (0, _store.getQueryFromState)(this.store.getState(), id);
        var doctype = queryResults.definition && queryResults.definition.doctype;
        var data = hydrated && doctype ? this.hydrateDocuments(doctype, queryResults.data) : queryResults.data;
        return (0, _objectSpread2.default)({}, queryResults, {
          data: data
        });
      } catch (e) {
        console.warn('Could not getQueryFromState', id, e.message);
        return null;
      }
    }
    /**
     * Performs a complete OAuth flow using a Cordova webview for auth.
     * The `register` method's name has been chosen for compat reasons with the Authentication compo.
     *
     * @param   {string} cozyURL Receives the URL of the cozy instance.
     * @returns {object}   Contains the fetched token and the client information.
     */

  }, {
    key: "register",
    value: function register(cozyURL) {
      var stackClient = this.getStackClient();
      stackClient.setUri(cozyURL);
      return this.startOAuthFlow(_mobile.authenticateWithCordova);
    }
    /**
     * Performs a complete OAuth flow, including updating the internal token at the end.
     *
     * @param   {Function} openURLCallback Receives the URL to present to the user as a parameter, and should return a promise that resolves with the URL the user was redirected to after accepting the permissions.
     * @returns {object}   Contains the fetched token and the client information. These should be stored and used to restore the client.
     */

  }, {
    key: "startOAuthFlow",
    value: function () {
      var _startOAuthFlow = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee12(openURLCallback) {
        var stackClient;
        return _regenerator.default.wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                stackClient = this.getStackClient();
                _context12.next = 3;
                return stackClient.register();

              case 3:
                return _context12.abrupt("return", this.authorize(openURLCallback));

              case 4:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this);
      }));

      return function startOAuthFlow(_x15) {
        return _startOAuthFlow.apply(this, arguments);
      };
    }()
  }, {
    key: "authorize",
    value: function () {
      var _authorize = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee13(openURLCallback) {
        var stackClient, stateCode, url, redirectedURL, code, token, _stackClient;

        return _regenerator.default.wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                _context13.prev = 0;
                stackClient = this.getStackClient();
                stateCode = stackClient.generateStateCode();
                url = stackClient.getAuthCodeURL(stateCode);
                _context13.next = 6;
                return openURLCallback(url);

              case 6:
                redirectedURL = _context13.sent;
                code = stackClient.getAccessCodeFromURL(redirectedURL, stateCode);
                _context13.next = 10;
                return stackClient.fetchAccessToken(code);

              case 10:
                token = _context13.sent;
                stackClient.setToken(token);
                return _context13.abrupt("return", {
                  token: token,
                  infos: stackClient.oauthOptions,
                  client: stackClient.oauthOptions // for compat with Authentication comp reasons

                });

              case 15:
                _context13.prev = 15;
                _context13.t0 = _context13["catch"](0);

                /* if REGISTRATION_ABORT is emited, we have to unregister the client. */
                if (_context13.t0.message === _const.REGISTRATION_ABORT) {
                  _stackClient = this.getStackClient();

                  _stackClient.unregister();
                }

                throw _context13.t0;

              case 19:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee13, this, [[0, 15]]);
      }));

      return function authorize(_x16) {
        return _authorize.apply(this, arguments);
      };
    }()
    /**
     * Renews the token if, for instance, new permissions are required or token
     * has expired.
     *
     * @returns {object}   Contains the fetched token and the client information.
     */

  }, {
    key: "renewAuthorization",
    value: function renewAuthorization() {
      return this.authorize(_mobile.authenticateWithCordova);
    }
    /**
     * Sets the internal store of the client. Use this when you want to have cozy-client's
     * internal store colocated with your existing Redux store.
     *
     * Typically, you would need to do this only once in your application, this is why
     * setStore throws if you do it twice. If you really need to set the store again,
     * use options.force = true.
     *
     * @example
     * ```
     * const client = new CozyClient()
     * const store = createStore(combineReducers({
     *   todos: todoReducer,
     *   cozy: client.reducer()
     * })
     * client.setStore(store)
     * ```
     *
     * @param {ReduxStore} store - A redux store
     * @param {object} options - Options
     * @param {boolean} options.force - Will deactivate throwing when client's store already exists
     */

  }, {
    key: "setStore",
    value: function setStore(store) {
      var _ref5 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          _ref5$force = _ref5.force,
          force = _ref5$force === void 0 ? false : _ref5$force;

      if (store === undefined) {
        throw new Error('Store is undefined');
      } else if (this.store && !force) {
        throw new Error("Client already has a store, it is forbidden to change store.\nsetStore must be called before any query is executed. Try to\ncall setStore earlier in your code, preferably just after the\ninstantiation of the client.");
      }

      this.store = store;
    }
  }, {
    key: "ensureStore",
    value: function ensureStore() {
      if (!this.store) {
        this.setStore((0, _store.createStore)());
      }
    }
    /**
     * Returns whether the client has been revoked on the server
     */

  }, {
    key: "checkForRevocation",
    value: function () {
      var _checkForRevocation = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee14() {
        return _regenerator.default.wrap(function _callee14$(_context14) {
          while (1) {
            switch (_context14.prev = _context14.next) {
              case 0:
                return _context14.abrupt("return", this.stackClient.checkForRevocation());

              case 1:
              case "end":
                return _context14.stop();
            }
          }
        }, _callee14, this);
      }));

      return function checkForRevocation() {
        return _checkForRevocation.apply(this, arguments);
      };
    }()
    /** Sets public attribute and emits event related to revocation */

  }, {
    key: "handleRevocationChange",
    value: function handleRevocationChange(state) {
      if (state) {
        this.isRevoked = true;
        this.emit('revoked');
      } else {
        this.isRevoked = false;
        this.emit('unrevoked');
      }
    }
    /** Emits event when token is refreshed */

  }, {
    key: "handleTokenRefresh",
    value: function handleTokenRefresh(token) {
      this.emit('tokenRefreshed');

      if (this.options.onTokenRefresh) {
        deprecatedHandler("Using onTokenRefresh is deprecated, please use events like this: cozyClient.on('tokenRefreshed', token => console.log('Token has been refreshed', token)). https://git.io/fj3M3");
        this.options.onTokenRefresh(token);
      }
    }
    /**
     * If no stack client has been passed in options, creates a default stack
     * client and attaches handlers for revocation and token refresh.
     * If a stackClient has been passed in options, ensure it has handlers for
     * revocation and token refresh.
     *
     * If `oauth` options are passed, stackClient is an OAuthStackClient.
     */

  }, {
    key: "createClient",
    value: function createClient() {
      if (this.options.client) {
        console.warn('CozyClient: Using options.client is deprecated, please use options.stackClient.');
      }

      var warningForCustomHandlers = this.options.warningForCustomHandlers !== undefined ? this.options.warningForCustomHandlers : true;
      var stackClient = this.options.client || this.options.stackClient;
      var handlers = {
        onRevocationChange: this.handleRevocationChange,
        onTokenRefresh: this.handleTokenRefresh
      };

      if (stackClient) {
        this.stackClient = stackClient;

        if (!stackClient.options) {
          stackClient.options = {};
        }

        for (var _i = 0, _Object$keys = Object.keys(handlers); _i < _Object$keys.length; _i++) {
          var handlerName = _Object$keys[_i];

          if (!stackClient.options[handlerName]) {
            stackClient.options[handlerName] = handlers[handlerName];
          } else {
            if (warningForCustomHandlers) {
              console.warn("You passed a stackClient with its own ".concat(handlerName, ". It is not supported, unexpected things might happen."));
            }
          }
        }
      } else {
        var options = (0, _objectSpread2.default)({}, this.options, handlers);
        this.stackClient = this.options.oauth ? new _cozyStackClient.OAuthClient(options) : new _cozyStackClient.default(options);
      }

      this.client = new Proxy(this.stackClient, deprecatedHandler('Using cozyClient.client is deprecated, please use cozyClient.stackClient.'));
    }
  }, {
    key: "getClient",
    value: function getClient() {
      console.warn('CozyClient: getClient() is deprecated, please use getStackClient().');
      return this.getStackClient();
    }
  }, {
    key: "getStackClient",
    value: function getStackClient() {
      if (!this.stackClient) {
        this.createClient();
      }

      return this.stackClient;
    }
  }, {
    key: "reducer",
    value: function reducer() {
      return _store.default;
    }
  }, {
    key: "dispatch",
    value: function dispatch(action) {
      return this.store.dispatch(action);
    }
  }, {
    key: "generateId",
    value: function generateId() {
      var id = this.idCounter;
      this.idCounter++;
      return id;
    }
    /**
     * getInstanceOptions - Returns current instance options, such as domain or app slug
     *
     * @returns {object}
     */

  }, {
    key: "getInstanceOptions",
    value: function getInstanceOptions() {
      return this.instanceOptions;
    }
    /**
     * loadInstanceOptionsFromDOM - Loads the dataset injected by the Stack in web pages and exposes it through getInstanceOptions
     *
     * @param {string} [selector=[role=application]] A selector for the node that holds the dataset to load
     *
     * @returns {void}
     */

  }, {
    key: "loadInstanceOptionsFromDOM",
    value: function loadInstanceOptionsFromDOM() {
      var selector = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '[role=application]';
      var root = document.querySelector(selector);
      this.instanceOptions = root.dataset.cozy ? JSON.parse(root.dataset.cozy) : (0, _objectSpread2.default)({}, root.dataset); // convert from DOMStringMap to plain object
    }
    /**
     * Directly set the data in the store, without using a query
     * This is useful for cases like Pouch replication, which wants to
     * set some data in the store.
     *
     * @param data {Object} { doctype: [data] }
     */

  }, {
    key: "setData",
    value: function setData(data) {
      var _this8 = this;

      this.ensureStore();
      Object.entries(data).forEach(function (_ref6) {
        var _ref7 = (0, _slicedToArray2.default)(_ref6, 2),
            doctype = _ref7[0],
            data = _ref7[1];

        _this8.dispatch((0, _store.receiveQueryResult)(null, {
          data: data
        }));
      });
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return new _snapshots.CozyClient({
        uri: this.options.uri
      });
    }
  }], [{
    key: "fromOldClient",
    value: function fromOldClient(oldClient, options) {
      return new CozyClient((0, _objectSpread2.default)({
        uri: oldClient._url,
        token: oldClient._token.token
      }, options));
    }
    /**
     * To help with the transition from cozy-client-js to cozy-client, it is possible to instantiate
     * a client with an OAuth-based instance of cozy-client-js.
     *
     * Warning: unlike other instantiators, this one needs to be awaited.
     *
     * @returns {CozyClient} An instance of a client, configured from the old client
     */

  }, {
    key: "fromOldOAuthClient",
    value: function () {
      var _fromOldOAuthClient = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee15(oldClient, options) {
        var hasOauthCreds, token;
        return _regenerator.default.wrap(function _callee15$(_context15) {
          while (1) {
            switch (_context15.prev = _context15.next) {
              case 0:
                hasOauthCreds = oldClient._oauth && oldClient._authcreds != null;

                if (!hasOauthCreds) {
                  _context15.next = 6;
                  break;
                }

                _context15.next = 4;
                return oldClient._authcreds;

              case 4:
                token = _context15.sent.token;
                return _context15.abrupt("return", new CozyClient((0, _objectSpread2.default)({
                  uri: oldClient._url,
                  token: token
                }, options)));

              case 6:
              case "end":
                return _context15.stop();
            }
          }
        }, _callee15);
      }));

      return function fromOldOAuthClient(_x17, _x18) {
        return _fromOldOAuthClient.apply(this, arguments);
      };
    }()
    /** In konnector/service context, CozyClient can be instantiated from environment variables */

  }, {
    key: "fromEnv",
    value: function fromEnv(env) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      env = env || (typeof process !== 'undefined' ? process.env : {});
      var _env = env,
          COZY_URL = _env.COZY_URL,
          COZY_CREDENTIALS = _env.COZY_CREDENTIALS,
          NODE_ENV = _env.NODE_ENV;

      if (!COZY_URL || !COZY_CREDENTIALS) {
        throw new Error('Env used to instantiate CozyClient must have COZY_URL and COZY_CREDENTIALS');
      }

      if (NODE_ENV === 'development') {
        options.oauth = JSON.parse(COZY_CREDENTIALS);
      } else {
        options.token = COZY_CREDENTIALS.trim();
      }

      options.uri = COZY_URL.trim();
      return new CozyClient((0, _objectSpread2.default)({}, options));
    }
  }, {
    key: "registerHook",
    value: function registerHook(doctype, name, fn) {
      CozyClient.hooks = CozyClient.hooks || {};
      var hooks = CozyClient.hooks[doctype] = CozyClient.hooks[doctype] || {};
      hooks[name] = hooks[name] || [];
      hooks[name].push(fn);
    }
  }]);
  return CozyClient;
}();

CozyClient.fetchPolicies = _policies.default; //COZY_CLIENT_VERSION_PACKAGE in replaced by babel. See babel config

CozyClient.version = "13.15.0";

_microee.default.mixin(CozyClient);

var _default = CozyClient;
exports.default = _default;