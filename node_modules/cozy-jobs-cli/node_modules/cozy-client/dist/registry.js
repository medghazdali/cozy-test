"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

require("url-search-params-polyfill");

var _terms = _interopRequireDefault(require("./terms"));

var _constants = require("./constants");

var queryPartFromOptions = function queryPartFromOptions(options) {
  var query = new URLSearchParams(options).toString();
  return query ? "?".concat(query) : '';
};

var getBaseRoute = function getBaseRoute(app) {
  var type = app.type; // TODO node is an historic type, it should be `konnector`, check with the back

  var route = type === _constants.APP_TYPE.KONNECTOR || type === 'node' ? 'konnectors' : 'apps';
  return "/".concat(route);
};
/**
 *@typedef {RegistryApp}
 */


var Registry =
/*#__PURE__*/
function () {
  function Registry(options) {
    (0, _classCallCheck2.default)(this, Registry);

    if (!options.client) {
      throw new Error('Need to pass a client to instantiate a Registry API.');
    }

    this.client = options.client;
  }
  /**
   * Installs or updates an app from a source.
   *
   * Accepts the terms if the app has them.
   *
   * @param  {RegistryApp} app - App to be installed
   * @param  {string} source - String (ex: registry://drive/stable)
   * @returns {Promise}
   */


  (0, _createClass2.default)(Registry, [{
    key: "installApp",
    value: function () {
      var _installApp = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee(app, source) {
        var slug, terms, searchParams, isUpdate, querypart, verb, baseRoute;
        return _regenerator.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                slug = app.slug, terms = app.terms;
                searchParams = {};
                isUpdate = app.installed;
                if (isUpdate) searchParams.PermissionsAcked = isUpdate;
                if (source) searchParams.Source = source;
                querypart = queryPartFromOptions(searchParams);

                if (!terms) {
                  _context.next = 9;
                  break;
                }

                _context.next = 9;
                return _terms.default.save(this.client, terms);

              case 9:
                verb = app.installed ? 'PUT' : 'POST';
                baseRoute = getBaseRoute(app);
                return _context.abrupt("return", this.client.stackClient.fetchJSON(verb, "".concat(baseRoute, "/").concat(slug).concat(querypart)));

              case 12:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      return function installApp(_x, _x2) {
        return _installApp.apply(this, arguments);
      };
    }()
    /**
     * Uninstalls an app.
     */

  }, {
    key: "uninstallApp",
    value: function () {
      var _uninstallApp = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee2(app) {
        var slug, baseRoute;
        return _regenerator.default.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                slug = app.slug;
                baseRoute = getBaseRoute(app);
                return _context2.abrupt("return", this.client.stackClient.fetchJSON('DELETE', "".concat(baseRoute, "/").concat(slug)));

              case 3:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      return function uninstallApp(_x3) {
        return _uninstallApp.apply(this, arguments);
      };
    }()
    /**
     * Fetch at most 200 apps from the channel
     *
     * @param  {string} params - Fetching parameters
     * @param  {string} params.type - "webapp" or "konnector"
     * @param  {string} params.channel - "dev"/"beta"/"stable"
     *
     * @returns {Array<RegistryApp>}
     */

  }, {
    key: "fetchApps",
    value: function () {
      var _fetchApps = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee3(params) {
        var channel, type, searchParams, querypart, _ref, apps;

        return _regenerator.default.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                channel = params.channel, type = params.type;
                searchParams = {
                  limit: 200,
                  versionsChannel: channel,
                  latestChannelVersion: channel
                };
                querypart = new URLSearchParams(searchParams).toString();

                if (type) {
                  // Unfortunately, URLSearchParams encodes brackets so we have to do
                  // the querypart handling manually
                  querypart = querypart + "&filter[type]=".concat(type);
                }

                _context3.next = 6;
                return this.client.stackClient.fetchJSON('GET', "/registry?".concat(querypart));

              case 6:
                _ref = _context3.sent;
                apps = _ref.data;
                return _context3.abrupt("return", apps);

              case 9:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      return function fetchApps(_x4) {
        return _fetchApps.apply(this, arguments);
      };
    }()
    /**
     * Fetch the list of apps that are in maintenance mode
     *
     * @returns {Array<RegistryApp>}
     */

  }, {
    key: "fetchAppsInMaintenance",
    value: function fetchAppsInMaintenance() {
      return this.client.stackClient.fetchJSON('GET', '/registry/maintenance');
    }
    /**
     * Fetch the status of a single app on the registry
     *
     * @param  {string} slug - The slug of the app to fetch
     *
     * @returns {RegistryApp}
     */

  }, {
    key: "fetchApp",
    value: function fetchApp(slug) {
      return this.client.stackClient.fetchJSON('GET', "/registry/".concat(slug));
    }
  }]);
  return Registry;
}();

var _default = Registry;
exports.default = _default;