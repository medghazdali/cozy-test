"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.extractAndMergeDocument = exports.getCollectionFromSlice = exports.getDocumentFromSlice = exports.default = exports.mergeDocumentsWithRelationships = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _objectSpread4 = _interopRequireDefault(require("@babel/runtime/helpers/objectSpread"));

var _queries = require("./queries");

var _mutations = require("./mutations");

var _keyBy = _interopRequireDefault(require("lodash/keyBy"));

var _get = _interopRequireDefault(require("lodash/get"));

var _isEqual = _interopRequireDefault(require("lodash/isEqual"));

var _helpers = require("./helpers");

var storeDocument = function storeDocument(state, document) {
  var type = document._type;

  if (!type) {
    if (process.env.NODE_ENV !== 'production') {
      console.warn('Document without _type', document);
    }

    throw new Error('Document without _type');
  }

  if (!(0, _helpers.properId)(document)) {
    if (process.env.NODE_ENV !== 'production') {
      console.warn('Document without id', document);
    }

    throw new Error('Document without id');
  }

  var existingDoc = (0, _get.default)(state, [type, (0, _helpers.properId)(document)]);

  if ((0, _isEqual.default)(existingDoc, document)) {
    return state;
  } else {
    return (0, _objectSpread4.default)({}, state, (0, _defineProperty2.default)({}, type, (0, _objectSpread4.default)({}, state[type], (0, _defineProperty2.default)({}, (0, _helpers.properId)(document), mergeDocumentsWithRelationships(existingDoc, document)))));
  }
};

var mergeDocumentsWithRelationships = function mergeDocumentsWithRelationships() {
  var prevDocument = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var nextDocument = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var merged = (0, _objectSpread4.default)({}, prevDocument, nextDocument);
  if (prevDocument.relationships || nextDocument.relationships) merged.relationships = (0, _objectSpread4.default)({}, prevDocument.relationships, nextDocument.relationships);
  return merged;
}; // reducer


exports.mergeDocumentsWithRelationships = mergeDocumentsWithRelationships;

var documents = function documents() {
  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var action = arguments.length > 1 ? arguments[1] : undefined;

  if (!(0, _queries.isReceivingData)(action) && !(0, _mutations.isReceivingMutationResult)(action)) {
    return state;
  }

  var _action$response = action.response,
      data = _action$response.data,
      included = _action$response.included;
  if (!data || Array.isArray(data) && data.length === 0) return state;
  var updatedStateWithIncluded = included ? included.reduce(storeDocument, state) : state;

  if (!Array.isArray(data)) {
    return storeDocument(updatedStateWithIncluded, data);
  }

  return extractAndMergeDocument(data, updatedStateWithIncluded);
};

var _default = documents; // selector

exports.default = _default;

var getDocumentFromSlice = function getDocumentFromSlice() {
  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var doctype = arguments.length > 1 ? arguments[1] : undefined;
  var id = arguments.length > 2 ? arguments[2] : undefined;

  if (!doctype) {
    throw new Error('getDocumentFromSlice: Cannot retrieve document with undefined doctype');
  }

  if (!id) {
    throw new Error('getDocumentFromSlice: Cannot retrieve document with undefined id');
  }

  if (!state[doctype]) {
    if (process.env.NODE_ENV !== 'production') {
      console.warn("getDocumentFromSlice: ".concat(doctype, " is absent from the store's documents. State is"), state);
    }

    return null;
  } else if (!state[doctype][id]) {
    if (process.env.NODE_ENV !== 'production') {
      console.warn("getDocumentFromSlice: ".concat(doctype, ":").concat(id, " is absent from the store documents. State is"), state);
    }

    return null;
  }

  return state[doctype][id];
};

exports.getDocumentFromSlice = getDocumentFromSlice;

var getCollectionFromSlice = function getCollectionFromSlice() {
  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var doctype = arguments.length > 1 ? arguments[1] : undefined;

  if (!doctype) {
    throw new Error('getDocumentFromSlice: Cannot retrieve document with undefined doctype');
  }

  if (!state[doctype]) {
    if (process.env.NODE_ENV !== 'production') {
      console.warn("getCollectionFromSlice: ".concat(doctype, " is absent from the store documents. State is"), state);
    }

    return null;
  }

  return Object.values(state[doctype]);
};
/*
  This method has been created in order to get a returned object 
  in `data` with the full set on information coming potentielly from 
  Ã¬ncluded`

  This method should be somewhere else. The `document` shall not be 
  deal with included / data and so on. 

  This method takes data and included and merge both sources 
  together. It should be always up to date. The returned object 
  will be as full of informations as it can be.
*/


exports.getCollectionFromSlice = getCollectionFromSlice;

var extractAndMergeDocument = function extractAndMergeDocument(data, updatedStateWithIncluded) {
  var doctype = data[0]._type;

  if (!doctype) {
    throw new Error('Document without _type', data[0]);
  }

  var sortedData = (0, _keyBy.default)(data, _helpers.properId);
  var mergedData = {};

  if (updatedStateWithIncluded && updatedStateWithIncluded[doctype]) {
    Object.values(updatedStateWithIncluded[doctype]).map(function (dataState) {
      if (!mergedData[doctype]) mergedData[doctype] = {};
      var id = (0, _helpers.properId)(dataState);

      if (sortedData[id]) {
        mergedData[doctype][id] = (0, _objectSpread4.default)({}, dataState, sortedData[id], mergedData[doctype][id]);
      } else {
        mergedData[doctype][id] = (0, _objectSpread4.default)({}, dataState, mergedData[doctype][id]);
      }
    });
  }

  Object.values(sortedData).map(function (data) {
    if (!mergedData[doctype]) mergedData[doctype] = {};
    var id = (0, _helpers.properId)(data);

    if (mergedData[doctype][id]) {
      mergedData[doctype][id] = (0, _objectSpread4.default)({}, mergedData[doctype][id], data);
    } else {
      mergedData[doctype][id] = data;
    }
  });
  return (0, _objectSpread4.default)({}, updatedStateWithIncluded, mergedData);
};

exports.extractAndMergeDocument = extractAndMergeDocument;