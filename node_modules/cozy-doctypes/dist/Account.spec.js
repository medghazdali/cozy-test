"use strict";

/* eslint-env jest */
var _require = require('./testUtils'),
    cozyClient = _require.cozyClient;

var Account = require('./Account');

beforeAll(function () {
  Account.registerClient(cozyClient);
});
describe('helpers library', function () {
  describe('getAccountName', function () {
    it('should return _id property by default (fallback)', function () {
      var account = {
        _id: 'mock12345',
        auth: {
          token: '1234'
        }
      };
      expect(Account.getAccountName(account)).toBe(account._id);
    });
    it('should return _id property by default (fallback) if no auth property', function () {
      var account = {
        _id: 'mock12345'
      };
      expect(Account.getAccountName(account)).toBe(account._id);
    });
    it('should return auth.acountName property if it exists, prior to other auth properties', function () {
      var account = {
        _id: 'mock12345',
        auth: {
          accountName: 'myaccount'
        }
      };
      expect(Account.getAccountName(account)).toBe(account.auth.accountName);
    });
    it('should return auth.login property if it exists, prior to auth.identifier and auth.email', function () {
      var account = {
        _id: 'mock12345',
        auth: {
          login: 'myaccountlogin',
          identifier: 'myaccountidentifier',
          email: 'myaccount@email.mock'
        }
      };
      expect(Account.getAccountName(account)).toBe(account.auth.login);
    });
    it("should return auth.identifier property if it exists (prior to auth.email) and if auth.login doesn't", function () {
      var account = {
        _id: 'mock12345',
        auth: {
          identifier: 'myaccountidentifier',
          email: 'myaccount@email.mock'
        }
      };
      expect(Account.getAccountName(account)).toBe(account.auth.identifier);
    });
    it('should return auth.email property if it exists and if neither auth.login and neither auth.identifier exist', function () {
      var account = {
        _id: 'mock12345',
        auth: {
          email: 'myaccount@email.mock'
        }
      };
      expect(Account.getAccountName(account)).toBe(account.auth.email);
    });
  });
  describe('fromCipher', function () {
    var cipher;
    beforeEach(function () {
      cipher = {
        id: 'cipher-id',
        login: {
          username: 'username',
          password: 'password'
        }
      };
    });
    it('should return an io.cozy.accounts object with auth infos (no custom fields)', function () {
      var account = Account.fromCipher(cipher);
      expect(account).toEqual({
        auth: {
          login: 'username',
          password: 'password'
        },
        relationships: {
          vaultCipher: {
            _id: 'cipher-id',
            _type: 'com.bitwarden.ciphers',
            _protocol: 'bitwarden'
          }
        }
      });
    });
    it('should return an io.cozy.accounts object with auth infos (with custom fields)', function () {
      cipher.fields = [{
        name: 'timeout',
        value: '2000'
      }, {
        name: 'error',
        value: 'USER_ACTION_NEEDED'
      }];
      var account = Account.fromCipher(cipher);
      expect(account).toEqual({
        auth: {
          login: 'username',
          password: 'password',
          timeout: '2000',
          error: 'USER_ACTION_NEEDED'
        },
        relationships: {
          vaultCipher: {
            _id: 'cipher-id',
            _type: 'com.bitwarden.ciphers',
            _protocol: 'bitwarden'
          }
        }
      });
    });
    it('should handle null cipher', function () {
      var account = Account.fromCipher(null);
      expect(account).toEqual({
        auth: {}
      });
    });
  });
});