"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var Application = require('./Application');

var CozyFile = require('./File');
/**
 * Class representing the folder model.
 * @extends CozyFile
 */


var CozyFolder =
/*#__PURE__*/
function (_CozyFile) {
  (0, _inherits2.default)(CozyFolder, _CozyFile);

  function CozyFolder() {
    (0, _classCallCheck2.default)(this, CozyFolder);
    return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(CozyFolder).apply(this, arguments));
  }

  (0, _createClass2.default)(CozyFolder, null, [{
    key: "createFolderWithReference",

    /**
     * Create a folder with a reference to the given document
     * @param  {String}  path     Folder path
     * @param  {Object}  document Document to make reference to. Any doctype.
     * @return {Object}  Folder document
     */
    value: function () {
      var _createFolderWithReference = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee(path, document) {
        var collection, dirId, _ref, dirInfos;

        return _regenerator.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                collection = this.cozyClient.collection(CozyFile.doctype);
                _context.next = 3;
                return collection.ensureDirectoryExists(path);

              case 3:
                dirId = _context.sent;
                _context.next = 6;
                return collection.addReferencesTo(document, [{
                  _id: dirId
                }]);

              case 6:
                _context.next = 8;
                return collection.get(dirId);

              case 8:
                _ref = _context.sent;
                dirInfos = _ref.data;
                return _context.abrupt("return", dirInfos);

              case 11:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function createFolderWithReference(_x, _x2) {
        return _createFolderWithReference.apply(this, arguments);
      }

      return createFolderWithReference;
    }()
    /**
     * Returns a "Magic Folder", given its id
     * @param  {String} id Magic Folder id. `CozyFolder.magicFolders` contains the
     * ids of folders that can be magic folders.
     * @param {String} path Default path to use if magic folder does not exist
     * @return {Object} Folder document
     */

  }, {
    key: "ensureMagicFolder",
    value: function () {
      var _ensureMagicFolder = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee2(id, path) {
        var magicFolderDocument, folders, existingMagicFolder, magicFoldersValues;
        return _regenerator.default.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                magicFolderDocument = {
                  _type: Application.doctype,
                  _id: id
                };
                _context2.next = 3;
                return this.getReferencedFolders(magicFolderDocument);

              case 3:
                folders = _context2.sent;
                existingMagicFolder = folders.length ? folders[0] : null;

                if (!existingMagicFolder) {
                  _context2.next = 7;
                  break;
                }

                return _context2.abrupt("return", existingMagicFolder);

              case 7:
                magicFoldersValues = Object.values(this.magicFolders);

                if (magicFoldersValues.includes(id)) {
                  _context2.next = 10;
                  break;
                }

                throw new Error("Cannot create Magic folder with id ".concat(id, ". Allowed values are ").concat(magicFoldersValues.join(', '), "."));

              case 10:
                if (path) {
                  _context2.next = 12;
                  break;
                }

                throw new Error('Magic folder default path must be defined');

              case 12:
                return _context2.abrupt("return", this.createFolderWithReference(path, magicFolderDocument));

              case 13:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function ensureMagicFolder(_x3, _x4) {
        return _ensureMagicFolder.apply(this, arguments);
      }

      return ensureMagicFolder;
    }()
    /**
     * Returns an array of folder referenced by the given document
     * @param  {Object}  document  Document to get references from
     * @return {Array}             Array of folders referenced with the given
     * document
     */

  }, {
    key: "getReferencedFolders",
    value: function () {
      var _getReferencedFolders = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee3(document) {
        var _this = this;

        var _ref2, included;

        return _regenerator.default.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return this.cozyClient.collection(CozyFile.doctype).findReferencedBy(document);

              case 2:
                _ref2 = _context3.sent;
                included = _ref2.included;
                return _context3.abrupt("return", included.filter(function (folder) {
                  return !_this.isTrashed(folder);
                }));

              case 5:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function getReferencedFolders(_x5) {
        return _getReferencedFolders.apply(this, arguments);
      }

      return getReferencedFolders;
    }()
    /**
     * Returns an unique folder referenced with the given reference. Creates it
     * if it does not exist.
     * @param  {String}  path      Path used to create folder if the referenced
     * folder does not exist.
     * @param  {Object}  document  Document to create references from
     * @return {Objet}             Folder referenced with the give reference
     */

  }, {
    key: "ensureFolderWithReference",
    value: function () {
      var _ensureFolderWithReference = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee4(path, document) {
        var existingFolders, collection, dirId, _ref3, dirInfos;

        return _regenerator.default.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return this.getReferencedFolders(document);

              case 2:
                existingFolders = _context4.sent;

                if (!existingFolders.length) {
                  _context4.next = 5;
                  break;
                }

                return _context4.abrupt("return", existingFolders[0]);

              case 5:
                collection = this.cozyClient.collection(CozyFile.doctype);
                _context4.next = 8;
                return collection.ensureDirectoryExists(path);

              case 8:
                dirId = _context4.sent;
                _context4.next = 11;
                return collection.addReferencesTo(document, [{
                  _id: dirId
                }]);

              case 11:
                _context4.next = 13;
                return collection.get(dirId);

              case 13:
                _ref3 = _context4.sent;
                dirInfos = _ref3.data;
                return _context4.abrupt("return", dirInfos);

              case 16:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function ensureFolderWithReference(_x6, _x7) {
        return _ensureFolderWithReference.apply(this, arguments);
      }

      return ensureFolderWithReference;
    }()
    /**
     * Indicates if a folder is in trash
     * @param  {Object}  folder `io.cozy.files` document
     * @return {Boolean}        `true` if the folder is in trash, `false`
     * otherwise.
     */

  }, {
    key: "isTrashed",
    value: function isTrashed(folder) {
      return /^\/\.cozy_trash/.test(folder.attributes.path);
    }
  }]);
  return CozyFolder;
}(CozyFile);
/**
 * References used by the Cozy platform and apps for specific folders.
 */


CozyFolder.magicFolders = {
  ADMINISTRATIVE: "".concat(Application.doctype, "/administrative"),
  PHOTOS: "".concat(Application.doctype, "/photos"),
  PHOTOS_BACKUP: "".concat(Application.doctype, "/photos/mobile"),
  PHOTOS_UPLOAD: "".concat(Application.doctype, "/photos/upload"),
  NOTES_FOLDER: "".concat(Application.doctype, "/notes")
};
module.exports = CozyFolder;