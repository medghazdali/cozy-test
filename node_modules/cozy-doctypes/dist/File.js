"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var trimEnd = require('lodash/trimEnd');

var Document = require('./Document');

var FILENAME_WITH_EXTENSION_REGEX = /(.+)(\..*)$/;
/**
 * Class representing the file model.
 * @extends Document
 */

var CozyFile =
/*#__PURE__*/
function (_Document) {
  (0, _inherits2.default)(CozyFile, _Document);

  function CozyFile() {
    (0, _classCallCheck2.default)(this, CozyFile);
    return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(CozyFile).apply(this, arguments));
  }

  (0, _createClass2.default)(CozyFile, null, [{
    key: "getFullpath",

    /**
     * async getFullpath - Gets a file's path
     *
     * @param  {string} dirID  The id of the parent directory
     * @param  {string} name   The file's name
     * @return {string}        The full path of the file in the cozy
     **/
    value: function () {
      var _getFullpath = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee(dirId, name) {
        var parentDir, parentDirectoryPath;
        return _regenerator.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (dirId) {
                  _context.next = 2;
                  break;
                }

                throw new Error('You must provide a dirId');

              case 2:
                _context.next = 4;
                return this.get(dirId);

              case 4:
                parentDir = _context.sent;
                parentDirectoryPath = trimEnd(parentDir.path, '/');
                return _context.abrupt("return", "".concat(parentDirectoryPath, "/").concat(name));

              case 7:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function getFullpath(_x, _x2) {
        return _getFullpath.apply(this, arguments);
      }

      return getFullpath;
    }()
    /**
     * Move file to destination.
     *
     * @param   {string} fileId               - The file's id (required)
     * @param   {object} destination
     * @param   {string} destination.folderId - The destination folder's id (required)
     * @param   {string} destination.path     - The file's path after the move (optional, used to optimize performance in case of conflict)
     * @param   {string} force                - Whether we should overwrite the destination in case of conflict (defaults to false)
     * @returns {Promise}                     - A promise that returns the move action response and the deleted file id (if any) if resolved or an Error if rejected
     *
     */

  }, {
    key: "move",
    value: function () {
      var _move = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee2(fileId, destination) {
        var force,
            folderId,
            path,
            filesCollection,
            resp,
            destinationPath,
            movedFile,
            filename,
            conflictResp,
            _resp,
            _args2 = arguments;

        return _regenerator.default.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                force = _args2.length > 2 && _args2[2] !== undefined ? _args2[2] : false;
                folderId = destination.folderId, path = destination.path;
                filesCollection = this.cozyClient.collection('io.cozy.files');
                _context2.prev = 3;
                _context2.next = 6;
                return filesCollection.updateFileMetadata(fileId, {
                  dir_id: folderId
                });

              case 6:
                resp = _context2.sent;
                return _context2.abrupt("return", {
                  moved: resp.data,
                  deleted: null
                });

              case 10:
                _context2.prev = 10;
                _context2.t0 = _context2["catch"](3);

                if (!(_context2.t0.status === 409 && force)) {
                  _context2.next = 35;
                  break;
                }

                if (!path) {
                  _context2.next = 17;
                  break;
                }

                destinationPath = path;
                _context2.next = 24;
                break;

              case 17:
                _context2.next = 19;
                return this.get(fileId);

              case 19:
                movedFile = _context2.sent;
                filename = movedFile.name;
                _context2.next = 23;
                return this.getFullpath(folderId, filename);

              case 23:
                destinationPath = _context2.sent;

              case 24:
                _context2.next = 26;
                return filesCollection.statByPath(destinationPath);

              case 26:
                conflictResp = _context2.sent;
                _context2.next = 29;
                return filesCollection.destroy(conflictResp.data);

              case 29:
                _context2.next = 31;
                return filesCollection.updateFileMetadata(fileId, {
                  dir_id: folderId
                });

              case 31:
                _resp = _context2.sent;
                return _context2.abrupt("return", {
                  moved: _resp.data,
                  deleted: conflictResp.data.id
                });

              case 35:
                throw _context2.t0;

              case 36:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this, [[3, 10]]);
      }));

      function move(_x3, _x4) {
        return _move.apply(this, arguments);
      }

      return move;
    }()
    /**
     * Method to split both the filename and the extension
     *
     * @param {Object} file An io.cozy.files
     * @return {Object}  return an object with {filename: , extension: }
     */

  }, {
    key: "splitFilename",
    value: function splitFilename(file) {
      if (!file.name) throw new Error('file should have a name property ');

      if (file.type === 'file') {
        var match = file.name.match(FILENAME_WITH_EXTENSION_REGEX);

        if (match) {
          return {
            filename: match[1],
            extension: match[2]
          };
        }
      }

      return {
        filename: file.name,
        extension: ''
      };
    }
    /**
     *
     * Method to upload a file even if a file with the same name already exists.
     *
     * @param {String} path Fullpath for the file ex: path/to/
     * @param {Object} file HTML Object file
     * @param {Object} metadata An object containing the wanted metadata to attach
     */

  }, {
    key: "overrideFileForPath",
    value: function () {
      var _overrideFileForPath = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee3(path, file, metadata) {
        var filesCollection, existingFile, _existingFile$data, fileId, dirId, resp, _dirId, createdFile;

        return _regenerator.default.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                if (!path.endsWith('/')) path = path + '/';
                filesCollection = this.cozyClient.collection('io.cozy.files');
                _context3.prev = 2;
                _context3.next = 5;
                return filesCollection.statByPath(path + file.name);

              case 5:
                existingFile = _context3.sent;
                _existingFile$data = existingFile.data, fileId = _existingFile$data.id, dirId = _existingFile$data.dir_id;
                _context3.next = 9;
                return filesCollection.updateFile(file, {
                  dirId: dirId,
                  fileId: fileId,
                  metadata: metadata
                });

              case 9:
                resp = _context3.sent;
                return _context3.abrupt("return", resp);

              case 13:
                _context3.prev = 13;
                _context3.t0 = _context3["catch"](2);

                if (!/Not Found/.test(_context3.t0)) {
                  _context3.next = 23;
                  break;
                }

                _context3.next = 18;
                return filesCollection.ensureDirectoryExists(path);

              case 18:
                _dirId = _context3.sent;
                _context3.next = 21;
                return filesCollection.createFile(file, {
                  dirId: _dirId,
                  metadata: metadata
                });

              case 21:
                createdFile = _context3.sent;
                return _context3.abrupt("return", createdFile);

              case 23:
                throw _context3.t0;

              case 24:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this, [[2, 13]]);
      }));

      function overrideFileForPath(_x5, _x6, _x7) {
        return _overrideFileForPath.apply(this, arguments);
      }

      return overrideFileForPath;
    }()
    /**
     * Method to generate a new filename if there is a conflict
     *
     * @param {String} filenameWithoutExtension A filename without the extension
     * @return {String} A filename with the right suffix
     */

  }, {
    key: "generateNewFileNameOnConflict",
    value: function generateNewFileNameOnConflict(filenameWithoutExtension) {
      //Check if the string ends by _1
      var regex = new RegExp('(_)([0-9]+)$');
      var matches = filenameWithoutExtension.match(regex);

      if (matches) {
        var versionNumber = parseInt(matches[2]); //increment versionNumber

        versionNumber++;
        var newFilenameWithoutExtension = filenameWithoutExtension.replace(new RegExp('(_)([0-9]+)$'), "_".concat(versionNumber));
        return newFilenameWithoutExtension;
      } else {
        return "".concat(filenameWithoutExtension, "_1");
      }
    }
  }, {
    key: "generateFileNameForRevision",
    value: function generateFileNameForRevision(file, revision, f) {
      var _CozyFile$splitFilena = CozyFile.splitFilename({
        name: file.name,
        type: 'file'
      }),
          filename = _CozyFile$splitFilena.filename,
          extension = _CozyFile$splitFilena.extension;

      return "".concat(filename, "_").concat(f(revision.updated_at, 'DD MMMM - HH[h]mm')).concat(extension);
    }
    /**
     * The goal of this method is to upload a file based on a conflict strategy.
     * Be careful: We need to check if the file exists by doing a statByPath query
     * before trying to upload the file since if we post and the stack return a
     * 409 conflict, we will get a SPDY_ERROR_PROTOCOL on Chrome. This is the only
     * viable workaround
     * If there is no conflict, then we upload the file.
     * If there is a conflict, then we apply the conflict strategy : `erase` or `rename`
     * @param {String} name File Name
     * @param {ArrayBuffer} file data
     * @param {String} dirId dir id where to upload
     * @param {String} conflictStrategy Actually only 2 hardcoded strategies 'erase' or 'rename'
     * @param {Object} metadata An object containing the metadata to attach
     * @param {String} contentType content type of the file
     */

  }, {
    key: "uploadFileWithConflictStrategy",
    value: function () {
      var _uploadFileWithConflictStrategy = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee4(name, file, dirId, conflictStrategy, metadata, contentType) {
        var filesCollection, path, existingFile, fileId, resp, _CozyFile$splitFilena2, filename, extension, newFileName;

        return _regenerator.default.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                filesCollection = this.cozyClient.collection('io.cozy.files');
                _context4.prev = 1;
                _context4.next = 4;
                return CozyFile.getFullpath(dirId, name);

              case 4:
                path = _context4.sent;
                _context4.next = 7;
                return filesCollection.statByPath(path);

              case 7:
                existingFile = _context4.sent;
                fileId = existingFile.data.id;

                if (!(conflictStrategy === 'erase')) {
                  _context4.next = 16;
                  break;
                }

                _context4.next = 12;
                return filesCollection.updateFile(file, {
                  dirId: dirId,
                  fileId: fileId,
                  name: name,
                  metadata: metadata,
                  contentType: contentType
                });

              case 12:
                resp = _context4.sent;
                return _context4.abrupt("return", resp);

              case 16:
                _CozyFile$splitFilena2 = CozyFile.splitFilename({
                  name: name,
                  type: 'file'
                }), filename = _CozyFile$splitFilena2.filename, extension = _CozyFile$splitFilena2.extension;
                newFileName = CozyFile.generateNewFileNameOnConflict(filename) + extension; //recall itself with the newFilename.

                return _context4.abrupt("return", CozyFile.uploadFileWithConflictStrategy(newFileName, file, dirId, conflictStrategy, metadata, contentType));

              case 19:
                _context4.next = 28;
                break;

              case 21:
                _context4.prev = 21;
                _context4.t0 = _context4["catch"](1);

                if (!/Not Found/.test(_context4.t0.message)) {
                  _context4.next = 27;
                  break;
                }

                _context4.next = 26;
                return CozyFile.upload(name, file, dirId, metadata, contentType);

              case 26:
                return _context4.abrupt("return", _context4.sent);

              case 27:
                throw _context4.t0;

              case 28:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this, [[1, 21]]);
      }));

      function uploadFileWithConflictStrategy(_x8, _x9, _x10, _x11, _x12, _x13) {
        return _uploadFileWithConflictStrategy.apply(this, arguments);
      }

      return uploadFileWithConflictStrategy;
    }()
    /**
     *
     * @param {String} name File's name
     * @param {ArrayBuffer} file
     * @param {String} dirId
     * @param {Object} metadata
     * @param {String} contentType
     */

  }, {
    key: "upload",
    value: function () {
      var _upload = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee5(name, file, dirId, metadata) {
        var contentType,
            _args5 = arguments;
        return _regenerator.default.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                contentType = _args5.length > 4 && _args5[4] !== undefined ? _args5[4] : 'image/jpeg';
                return _context5.abrupt("return", this.cozyClient.collection('io.cozy.files').createFile(file, {
                  name: name,
                  dirId: dirId,
                  contentType: contentType,
                  lastModifiedDate: new Date(),
                  metadata: metadata
                }));

              case 2:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function upload(_x14, _x15, _x16, _x17) {
        return _upload.apply(this, arguments);
      }

      return upload;
    }()
  }]);
  return CozyFile;
}(Document);

CozyFile.doctype = 'io.cozy.files';
module.exports = CozyFile;