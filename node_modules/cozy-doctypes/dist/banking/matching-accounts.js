"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _objectSpread2 = _interopRequireDefault(require("@babel/runtime/helpers/objectSpread"));

var sortBy = require('lodash/sortBy');

var _require = require('./matching-tools'),
    eitherIncludes = _require.eitherIncludes;

var _require2 = require('./slug-account'),
    getSlugFromInstitutionLabel = _require2.getSlugFromInstitutionLabel;

var findExactMatch = function findExactMatch(attr, account, existingAccounts) {
  var sameAttr = existingAccounts.filter(function (existingAccount) {
    return existingAccount[attr] === account[attr];
  });

  if (sameAttr.length === 1) {
    return {
      match: sameAttr[0],
      method: attr + '-exact'
    };
  } else if (sameAttr.length > 1) {
    return {
      matches: sameAttr,
      method: attr + '-exact'
    };
  } else {
    return null;
  }
};

var untrimmedAccountNumber = /^(?:[A-Za-z]+)?-?([0-9]+)-?(?:[A-Za-z]+)?$/;
var redactedCreditCard = /xxxx xxxx xxxx (\d{4})/;

var normalizeAccountNumber = function normalizeAccountNumber(number, iban) {
  iban = iban && iban.replace(/\s/g, '');
  number = number && !number.match(redactedCreditCard) ? number.replace(/\s/g, '') : number;
  var match;

  if (iban && iban.length == 27) {
    return iban.substr(14, 11);
  }

  if (!number) {
    return number;
  }

  if (number.length == 23) {
    // Must be an IBAN without the COUNTRY code
    // See support demand #9102 with BI
    // We extract the account number from the IBAN
    // COUNTRY (4) BANK (5) COUNTER (5) NUMBER (11) KEY (2)
    // FRXX 16275 10501 00300060030 00
    return number.substr(10, 11);
  } else if (number.length == 16) {
    // Linxo sends Bank account number that contains
    // the counter number
    return number.substr(5, 11);
  } else if (number.length > 11 && (match = number.match(untrimmedAccountNumber))) {
    // Some account numbers from BI are in the form
    // CC-00300060030 (CC for Compte Courant) or
    // LEO-00300060030
    return match[1];
  } else {
    return number;
  }
};
/**
 * If either of the account numbers has length 11 and one is contained
 * in the other, it's a match
 */


var approxNumberMatch = function approxNumberMatch(account, existingAccount) {
  return existingAccount.number && account.number && (existingAccount.number.length === 11 || account.number.length === 11) && eitherIncludes(existingAccount.number, account.number);
};

var creditCardMatch = function creditCardMatch(account, existingAccount) {
  var ccAccount, lastDigits;

  for (var _i = 0, _arr = [account, existingAccount]; _i < _arr.length; _i++) {
    var acc = _arr[_i];
    var match = acc.number && acc.number.match(redactedCreditCard);

    if (match) {
      ccAccount = acc;
      lastDigits = match[1];
    }
  }

  var other = ccAccount === account ? existingAccount : account;

  if (other.number.slice(-4) === lastDigits) {
    return true;
  }
};

var slugMatch = function slugMatch(account, existingAccount) {
  var possibleSlug = getSlugFromInstitutionLabel(account.institutionLabel);
  var possibleSlugExisting = getSlugFromInstitutionLabel(existingAccount.institutionLabel);
  return !possibleSlug || !possibleSlugExisting || possibleSlug === possibleSlugExisting;
};

var score = function score(account, existingAccount) {
  var methods = [];
  var res = {
    account: existingAccount,
    methods: methods
  };
  var points = 0;
  /* To avoid accounts from different banks to be considered */

  if (!slugMatch(account, existingAccount)) {
    points -= 1000;
  }

  if (approxNumberMatch(account, existingAccount)) {
    points += 50;
    methods.push('approx-number');
  } else {
    points -= 50;
  }

  if (account.type === existingAccount.type) {
    points += 50;
    methods.push('same-type');
  }

  if ((account.type === 'CreditCard' || existingAccount.type === 'CreditCard') && creditCardMatch(account, existingAccount)) {
    points += 150;
    methods.push('credit-card-number');
  }

  if (account.currency) {
    var sameCurrency = existingAccount.rawNumber && existingAccount.rawNumber.includes(account.currency) || existingAccount.label && existingAccount.label.includes(account.currency) || existingAccount.originalBankLabel && existingAccount.originalBankLabel.includes(account.currency);

    if (sameCurrency) {
      points += 50;
      methods.push('currency');
    }
  }

  res.points = points;
  return res;
};

var normalizeAccount = function normalizeAccount(account) {
  var normalizedAccountNumber = normalizeAccountNumber(account.number, account.iban);
  return (0, _objectSpread2.default)({}, account, {
    rawNumber: account.number,
    number: normalizedAccountNumber
  });
};

var exactMatchAttributes = ['iban', 'number'];

var eqNotUndefined = function eqNotUndefined(attr1, attr2) {
  return attr1 && attr1 === attr2;
};

var findMatch = function findMatch(account, existingAccounts) {
  // Start with exact attribute matches
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = exactMatchAttributes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var exactAttribute = _step.value;

      if (account[exactAttribute]) {
        var result = findExactMatch(exactAttribute, account, existingAccounts);

        if (result && result.match) {
          return result;
        }
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return != null) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  var matchOriginalNumber = existingAccounts.find(function (otherAccount) {
    return eqNotUndefined(account.originalNumber, otherAccount.number) || eqNotUndefined(account.number, otherAccount.originalNumber);
  });

  if (matchOriginalNumber) {
    return {
      match: matchOriginalNumber,
      method: 'originalNumber-exact'
    };
  }

  var matchRawNumberCurrencyType = existingAccounts.find(function (otherAccount) {
    return (eqNotUndefined(account.rawNumber, otherAccount.number) || eqNotUndefined(account.number, otherAccount.rawNumber)) && otherAccount.type == account.type && otherAccount.currency == account.currency;
  });

  if (matchRawNumberCurrencyType) {
    return {
      match: matchRawNumberCurrencyType,
      method: 'rawNumber-exact-currency-type'
    };
  } // Now we get more fuzzy and score accounts


  var scored = sortBy(existingAccounts.map(function (existingAccount) {
    return score(account, existingAccount);
  }), function (x) {
    return -x.points;
  });
  var candidates = scored.filter(function (x) {
    return x.points > 0;
  });

  if (candidates.length > 0) {
    return {
      match: candidates[0].account,
      method: candidates[0].methods.join('-')
    };
  }
};

var matchAccounts = function matchAccounts(fetchedAccounts, existingAccounts) {
  fetchedAccounts = fetchedAccounts.map(normalizeAccount);
  var toMatch = (0, _toConsumableArray2.default)(existingAccounts).map(normalizeAccount);
  var results = [];
  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = fetchedAccounts[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var fetchedAccount = _step2.value;
      var matchResult = findMatch(fetchedAccount, toMatch);

      if (matchResult) {
        var i = toMatch.indexOf(matchResult.match);
        toMatch.splice(i, 1);
        results.push((0, _objectSpread2.default)({
          account: fetchedAccount
        }, matchResult));
      } else {
        results.push({
          account: fetchedAccount
        });
      }
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
        _iterator2.return();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  return results;
};

module.exports = {
  matchAccounts: matchAccounts,
  normalizeAccountNumber: normalizeAccountNumber,
  score: score
};