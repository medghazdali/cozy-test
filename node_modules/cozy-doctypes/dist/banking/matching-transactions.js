"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _taggedTemplateLiteral2 = _interopRequireDefault(require("@babel/runtime/helpers/taggedTemplateLiteral"));

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

function _templateObject() {
  var data = (0, _taggedTemplateLiteral2.default)(["", "{2,}"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

var groupBy = require('lodash/groupBy');

var sortBy = require('lodash/sortBy');

var _require = require('./matching-tools'),
    eitherIncludes = _require.eitherIncludes;

var getDateTransaction = function getDateTransaction(op) {
  return op.date.substr(0, 10);
};
/**
 * Groups `iterables` via `grouper` and returns an iterator
 * that yields [groupKey, groups]
 */


var zipGroup =
/*#__PURE__*/
_regenerator.default.mark(function zipGroup(iterables, grouper) {
  var grouped, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _loop, _iterator, _step;

  return _regenerator.default.wrap(function zipGroup$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          grouped = iterables.map(function (items) {
            return groupBy(items, grouper);
          });
          _iteratorNormalCompletion = true;
          _didIteratorError = false;
          _iteratorError = undefined;
          _context2.prev = 4;
          _loop =
          /*#__PURE__*/
          _regenerator.default.mark(function _loop() {
            var key, groups;
            return _regenerator.default.wrap(function _loop$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    key = _step.value;
                    groups = grouped.map(function (keyedGroups) {
                      return keyedGroups[key] || [];
                    });
                    _context.next = 4;
                    return [key, groups];

                  case 4:
                  case "end":
                    return _context.stop();
                }
              }
            }, _loop);
          });
          _iterator = Object.keys(grouped[0]).sort()[Symbol.iterator]();

        case 7:
          if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
            _context2.next = 12;
            break;
          }

          return _context2.delegateYield(_loop(), "t0", 9);

        case 9:
          _iteratorNormalCompletion = true;
          _context2.next = 7;
          break;

        case 12:
          _context2.next = 18;
          break;

        case 14:
          _context2.prev = 14;
          _context2.t1 = _context2["catch"](4);
          _didIteratorError = true;
          _iteratorError = _context2.t1;

        case 18:
          _context2.prev = 18;
          _context2.prev = 19;

          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }

        case 21:
          _context2.prev = 21;

          if (!_didIteratorError) {
            _context2.next = 24;
            break;
          }

          throw _iteratorError;

        case 24:
          return _context2.finish(21);

        case 25:
          return _context2.finish(18);

        case 26:
        case "end":
          return _context2.stop();
      }
    }
  }, zipGroup, null, [[4, 14, 18, 26], [19,, 21, 25]]);
});

var squash = function squash(str, char) {
  var rx = new RegExp(String.raw(_templateObject(), char), 'gi');
  return str && str.replace(rx, char);
};

var redactedNumber = /\b[0-9X]+\b/gi;
var dateRx = /\b\d{2}\/\d{2}\/\d{4}\b/g;

var cleanLabel = function cleanLabel(label) {
  return label && label.replace(redactedNumber, '');
};

var withoutDate = function withoutDate(str) {
  return str && str.replace(dateRx, '');
};

var compacted = function compacted(str) {
  return str && str.replace(/\s/g, '').replace(/-/g, '');
};

var scoreLabel = function scoreLabel(newTr, existingTr) {
  if (squash(existingTr.originalBankLabel, ' ') === squash(newTr.originalBankLabel, ' ')) {
    return [200, 'originalBankLabel'];
  } else if (compacted(existingTr.originalBankLabel) === compacted(newTr.originalBankLabel)) {
    return [120, 'originalBankLabelCompacted'];
  } else if (withoutDate(existingTr.originalBankLabel) === withoutDate(newTr.originalBankLabel)) {
    // For some transfers, the date in the originalBankLabel is different between
    // BudgetInsight and Linxo
    return [150, 'originalBankLabelWithoutDate'];
  } else if (existingTr.label === newTr.label) {
    return [100, 'label'];
  } else if (eitherIncludes(existingTr.label.toLowerCase(), newTr.label.toLowerCase())) {
    return [70, 'eitherIncludes'];
  } else if (eitherIncludes(cleanLabel(existingTr.label.toLowerCase()), cleanLabel(newTr.label.toLowerCase()))) {
    return [50, 'fuzzy-eitherIncludes'];
  } else {
    // Nothing matches, we penalize so that the score is below 0
    return [-1000, 'label-penalty'];
  }
};

var DAY = 1000 * 60 * 60 * 24;

var getDeltaDate = function getDeltaDate(newTr, existingTr) {
  var nDate1 = new Date(newTr.date.substr(0, 10));
  var eDate1 = new Date(existingTr.date.substr(0, 10));
  var delta = Math.abs(eDate1 - nDate1);

  if (newTr.realisationDate) {
    var nDate2 = new Date(newTr.realisationDate.substr(0, 10));
    var delta2 = Math.abs(eDate1 - nDate2);
    return Math.min(delta, delta2);
  } else {
    return delta;
  }
};

var scoreMatching = function scoreMatching(newTr, existingTr) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var methods = [];
  var res = {
    op: existingTr,
    methods: methods
  };

  if (options.maxDateDelta) {
    var delta = getDeltaDate(newTr, existingTr);

    if (delta > options.maxDateDelta) {
      // Early exit, transactions are two far off time-wise
      res.points = -1000;
      return res;
    } else {
      methods.push('approx-date');
    }
  }

  var _scoreLabel = scoreLabel(newTr, existingTr),
      _scoreLabel2 = (0, _slicedToArray2.default)(_scoreLabel, 2),
      labelPoints = _scoreLabel2[0],
      labelMethod = _scoreLabel2[1];

  methods.push(labelMethod);
  var amountDiff = Math.abs(existingTr.amount - newTr.amount);
  var amountPoints = amountDiff === 0 ? methods.push('amount') && 100 : -1000;
  var points = amountPoints + labelPoints;
  res.points = points;
  return res;
};

var matchTransaction = function matchTransaction(newTr, existingTrs) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var exactVendorId = existingTrs.find(function (existingTr) {
    return existingTr.vendorId && newTr.vendorId && existingTr.vendorId === newTr.vendorId;
  });

  if (exactVendorId) {
    return {
      match: exactVendorId,
      method: 'vendorId'
    };
  } // Now we try to do it based on originalBankLabel, label and amount.
  // We score candidates according to their degree of matching
  // with the current transaction.
  // Candidates with score below 0 will be discarded.


  var withPoints = existingTrs.map(function (existingTr) {
    return scoreMatching(newTr, existingTr, options);
  });
  var candidates = sortBy(withPoints, function (x) {
    return -x.points;
  }).filter(function (x) {
    return x.points > 0;
  });
  return candidates.length > 0 ? {
    match: candidates[0].op,
    method: candidates[0].methods.join('-')
  } : {
    candidates: candidates
  };
};
/**
 * Logic to match a transaction and removing it from the transactions to
 * match. `matchingFn` is the function used for matching.
 */


var matchTransactionToGroup =
/*#__PURE__*/
_regenerator.default.mark(function matchTransactionToGroup(newTrs, existingTrs) {
  var options,
      toMatch,
      _iteratorNormalCompletion2,
      _didIteratorError2,
      _iteratorError2,
      _iterator2,
      _step2,
      newTr,
      res,
      result,
      matchIdx,
      _args3 = arguments;

  return _regenerator.default.wrap(function matchTransactionToGroup$(_context3) {
    while (1) {
      switch (_context3.prev = _context3.next) {
        case 0:
          options = _args3.length > 2 && _args3[2] !== undefined ? _args3[2] : {};
          toMatch = Array.isArray(existingTrs) ? (0, _toConsumableArray2.default)(existingTrs) : [];
          _iteratorNormalCompletion2 = true;
          _didIteratorError2 = false;
          _iteratorError2 = undefined;
          _context3.prev = 5;
          _iterator2 = newTrs[Symbol.iterator]();

        case 7:
          if (_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done) {
            _context3.next = 17;
            break;
          }

          newTr = _step2.value;
          res = {
            transaction: newTr
          };
          result = toMatch.length > 0 ? matchTransaction(newTr, toMatch, options) : null;

          if (result) {
            Object.assign(res, result);
            matchIdx = toMatch.indexOf(result.match);

            if (matchIdx > -1) {
              toMatch.splice(matchIdx, 1);
            }
          }

          _context3.next = 14;
          return res;

        case 14:
          _iteratorNormalCompletion2 = true;
          _context3.next = 7;
          break;

        case 17:
          _context3.next = 23;
          break;

        case 19:
          _context3.prev = 19;
          _context3.t0 = _context3["catch"](5);
          _didIteratorError2 = true;
          _iteratorError2 = _context3.t0;

        case 23:
          _context3.prev = 23;
          _context3.prev = 24;

          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
            _iterator2.return();
          }

        case 26:
          _context3.prev = 26;

          if (!_didIteratorError2) {
            _context3.next = 29;
            break;
          }

          throw _iteratorError2;

        case 29:
          return _context3.finish(26);

        case 30:
          return _context3.finish(23);

        case 31:
        case "end":
          return _context3.stop();
      }
    }
  }, matchTransactionToGroup, null, [[5, 19, 23, 31], [24,, 26, 30]]);
});
/**
 * Several logics to match transactions.
 *
 * First group transactions per day and match transactions in
 * intra-day mode.
 * Then relax the date constraint 1 day per 1 day to reach
 * a maximum of 5 days of differences
 */


var matchTransactions =
/*#__PURE__*/
_regenerator.default.mark(function matchTransactions(newTrs, existingTrs) {
  var unmatchedNew, unmatchedExisting, _iteratorNormalCompletion3, _didIteratorError3, _iteratorError3, _iterator3, _step3, _step3$value, date, _step3$value$, newGroup, existingGroup, _iteratorNormalCompletion4, _didIteratorError4, _iteratorError4, _iterator4, _step4, result, deltas, _i, _deltas, delta, _iteratorNormalCompletion5, _didIteratorError5, _iteratorError5, _iterator5, _step5, _result;

  return _regenerator.default.wrap(function matchTransactions$(_context4) {
    while (1) {
      switch (_context4.prev = _context4.next) {
        case 0:
          unmatchedNew = new Set(newTrs);
          unmatchedExisting = new Set(existingTrs); // eslint-disable-next-line no-unused-vars

          _iteratorNormalCompletion3 = true;
          _didIteratorError3 = false;
          _iteratorError3 = undefined;
          _context4.prev = 5;
          _iterator3 = zipGroup([newTrs, existingTrs], getDateTransaction)[Symbol.iterator]();

        case 7:
          if (_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done) {
            _context4.next = 41;
            break;
          }

          _step3$value = (0, _slicedToArray2.default)(_step3.value, 2), date = _step3$value[0], _step3$value$ = (0, _slicedToArray2.default)(_step3$value[1], 2), newGroup = _step3$value$[0], existingGroup = _step3$value$[1];
          _iteratorNormalCompletion4 = true;
          _didIteratorError4 = false;
          _iteratorError4 = undefined;
          _context4.prev = 12;
          _iterator4 = matchTransactionToGroup(newGroup, existingGroup)[Symbol.iterator]();

        case 14:
          if (_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done) {
            _context4.next = 24;
            break;
          }

          result = _step4.value;

          if (!result.match) {
            _context4.next = 21;
            break;
          }

          unmatchedExisting.delete(result.match);
          unmatchedNew.delete(result.transaction);
          _context4.next = 21;
          return result;

        case 21:
          _iteratorNormalCompletion4 = true;
          _context4.next = 14;
          break;

        case 24:
          _context4.next = 30;
          break;

        case 26:
          _context4.prev = 26;
          _context4.t0 = _context4["catch"](12);
          _didIteratorError4 = true;
          _iteratorError4 = _context4.t0;

        case 30:
          _context4.prev = 30;
          _context4.prev = 31;

          if (!_iteratorNormalCompletion4 && _iterator4.return != null) {
            _iterator4.return();
          }

        case 33:
          _context4.prev = 33;

          if (!_didIteratorError4) {
            _context4.next = 36;
            break;
          }

          throw _iteratorError4;

        case 36:
          return _context4.finish(33);

        case 37:
          return _context4.finish(30);

        case 38:
          _iteratorNormalCompletion3 = true;
          _context4.next = 7;
          break;

        case 41:
          _context4.next = 47;
          break;

        case 43:
          _context4.prev = 43;
          _context4.t1 = _context4["catch"](5);
          _didIteratorError3 = true;
          _iteratorError3 = _context4.t1;

        case 47:
          _context4.prev = 47;
          _context4.prev = 48;

          if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
            _iterator3.return();
          }

        case 50:
          _context4.prev = 50;

          if (!_didIteratorError3) {
            _context4.next = 53;
            break;
          }

          throw _iteratorError3;

        case 53:
          return _context4.finish(50);

        case 54:
          return _context4.finish(47);

        case 55:
          deltas = [3, 4, 5];
          _i = 0, _deltas = deltas;

        case 57:
          if (!(_i < _deltas.length)) {
            _context4.next = 91;
            break;
          }

          delta = _deltas[_i];
          _iteratorNormalCompletion5 = true;
          _didIteratorError5 = false;
          _iteratorError5 = undefined;
          _context4.prev = 62;
          _iterator5 = matchTransactionToGroup(Array.from(unmatchedNew), Array.from(unmatchedExisting), {
            maxDateDelta: delta * DAY
          })[Symbol.iterator]();

        case 64:
          if (_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done) {
            _context4.next = 74;
            break;
          }

          _result = _step5.value;

          if (_result.method) {
            _result.method += "-delta".concat(delta);
          }

          if (_result.match) {
            unmatchedExisting.delete(_result.match);
            unmatchedNew.delete(_result.transaction);
          }

          if (!(_result.match || delta === deltas[deltas.length - 1])) {
            _context4.next = 71;
            break;
          }

          _context4.next = 71;
          return _result;

        case 71:
          _iteratorNormalCompletion5 = true;
          _context4.next = 64;
          break;

        case 74:
          _context4.next = 80;
          break;

        case 76:
          _context4.prev = 76;
          _context4.t2 = _context4["catch"](62);
          _didIteratorError5 = true;
          _iteratorError5 = _context4.t2;

        case 80:
          _context4.prev = 80;
          _context4.prev = 81;

          if (!_iteratorNormalCompletion5 && _iterator5.return != null) {
            _iterator5.return();
          }

        case 83:
          _context4.prev = 83;

          if (!_didIteratorError5) {
            _context4.next = 86;
            break;
          }

          throw _iteratorError5;

        case 86:
          return _context4.finish(83);

        case 87:
          return _context4.finish(80);

        case 88:
          _i++;
          _context4.next = 57;
          break;

        case 91:
        case "end":
          return _context4.stop();
      }
    }
  }, matchTransactions, null, [[5, 43, 47, 55], [12, 26, 30, 38], [31,, 33, 37], [48,, 50, 54], [62, 76, 80, 88], [81,, 83, 87]]);
});

module.exports = {
  matchTransactions: matchTransactions,
  scoreMatching: scoreMatching
};