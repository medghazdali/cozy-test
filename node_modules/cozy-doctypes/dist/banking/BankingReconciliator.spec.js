"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _objectSpread2 = _interopRequireDefault(require("@babel/runtime/helpers/objectSpread"));

var BankingReconciliator = require('./BankingReconciliator');

var _require = require('..'),
    Document = _require.Document,
    BankAccount = _require.BankAccount,
    BankTransaction = _require.BankTransaction;

describe('banking reconciliator', function () {
  var reconciliator;
  var existingAccounts, existingTransactions;
  beforeEach(function () {
    var _id = 1;
    BankAccount.fetchAll = jest.fn().mockImplementation(function () {
      return Promise.resolve(existingAccounts);
    });
    Document.createOrUpdate = jest.fn().mockImplementation(function (attrs) {
      return Promise.resolve((0, _objectSpread2.default)({}, attrs, {
        _id: _id++
      }));
    });
    BankTransaction.fetchAll = jest.fn().mockImplementation(function () {
      return Promise.resolve(existingTransactions);
    });
    reconciliator = new BankingReconciliator({
      BankAccount: BankAccount,
      BankTransaction: BankTransaction
    });
  });
  afterEach(function () {
    jest.restoreAllMocks();
  });

  var fmtCreateOrUpdateCall = function fmtCreateOrUpdateCall(call) {
    var doc = call[0];
    return doc.label;
  };

  it('should correctly reconciliate when accounts do not exist',
  /*#__PURE__*/
  (0, _asyncToGenerator2.default)(
  /*#__PURE__*/
  _regenerator.default.mark(function _callee() {
    return _regenerator.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            existingAccounts = [];
            existingTransactions = [];
            _context.next = 4;
            return reconciliator.save([{
              vendorId: 1,
              balance: 1000,
              label: 'Bank account 1'
            }], [{
              amount: -100,
              label: 'Debit 100',
              vendorAccountId: 1,
              date: '2018-06-27T00:00'
            }]);

          case 4:
            expect(Document.createOrUpdate).toHaveBeenCalledTimes(2);

          case 5:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  })));
  it('should correctly reconciliate when accounts exist',
  /*#__PURE__*/
  (0, _asyncToGenerator2.default)(
  /*#__PURE__*/
  _regenerator.default.mark(function _callee2() {
    return _regenerator.default.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            existingAccounts = [{
              vendorId: 1,
              number: '1',
              _id: 123,
              balance: 2000,
              label: 'Bank account 1'
            }];
            existingTransactions = [{
              vendorAccountId: 1,
              vendorId: 123,
              date: '2018-06-25T00:00',
              label: 'Debit 200',
              amount: -200
            }];
            _context2.next = 4;
            return reconciliator.save([{
              number: '1',
              // existing account
              vendorId: 2,
              // from a new connector account
              balance: 1000,
              label: 'Bank account 1'
            }, {
              number: '1',
              // Same number as above, but the existing account
              vendorId: 2,
              // has already been matched, so this account
              balance: 1000,
              // will be saved
              label: 'Bank account 1 - Titres'
            }], [{
              amount: -200,
              label: 'Debit 200',
              vendorAccountId: 2,
              date: '2018-06-24T00:00' // prior to split date and doesn't exist, saved

            }, {
              amount: -100,
              label: 'Debit 100',
              vendorAccountId: 2,
              date: '2018-06-27T00:00'
            }]);

          case 4:
            expect(Document.createOrUpdate).toHaveBeenCalledTimes(4);
            expect(Document.createOrUpdate.mock.calls.map(fmtCreateOrUpdateCall)).toMatchSnapshot();

          case 6:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  })));
  it('should pass stack transactions belonging to reconciliated accounts to BankTransaction::reconciliate',
  /*#__PURE__*/
  (0, _asyncToGenerator2.default)(
  /*#__PURE__*/
  _regenerator.default.mark(function _callee3() {
    var fetchedAccounts, fetchedTransactions;
    return _regenerator.default.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            existingAccounts = [{
              vendorId: 1,
              number: '1',
              _id: 123,
              balance: 2000,
              label: 'Bank account 1'
            }, {
              vendorId: 1,
              number: '1337',
              _id: 124,
              balance: 2000,
              label: 'Bank account 2 from another konnector'
            }];
            existingTransactions = [{
              vendorAccountId: 1,
              vendorId: 123,
              date: '2018-06-25T00:00',
              label: 'Debit 200',
              amount: -200,
              account: 123
            }, {
              vendorAccountId: 1,
              vendorId: 124,
              date: '2018-06-25T00:00',
              label: 'Debit 200',
              amount: -200,
              account: 123
            }, {
              vendorAccountId: 2,
              vendorId: 125,
              date: '2018-06-25T00:00',
              label: 'Debit 300 from another konnector',
              amount: -300,
              account: 124
            }];
            jest.spyOn(BankTransaction, 'reconciliate');
            fetchedAccounts = [{
              number: '1',
              // existing account
              vendorId: 2,
              // from a new connector account
              balance: 1000,
              label: 'Bank account 1'
            }];
            fetchedTransactions = [{
              amount: -400,
              label: 'Debit 400',
              vendorAccountId: 2,
              date: '2018-06-22T00:00' // prior to split date and doesn't exist, saved

            }, {
              amount: -100,
              label: 'Debit 100',
              vendorAccountId: 2,
              date: '2018-06-27T00:00'
            }];
            _context3.next = 7;
            return reconciliator.save(fetchedAccounts, fetchedTransactions);

          case 7:
            expect(BankTransaction.reconciliate).toHaveBeenCalledWith(fetchedTransactions, [existingTransactions[0], existingTransactions[1]], {});
            expect(Document.createOrUpdate.mock.calls.map(fmtCreateOrUpdateCall)).toMatchSnapshot();

          case 9:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  })));
});