"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _objectSpread2 = _interopRequireDefault(require("@babel/runtime/helpers/objectSpread"));

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var keyBy = require('lodash/keyBy');

var groupBy = require('lodash/groupBy');

var maxBy = require('lodash/maxBy');

var addDays = require('date-fns/add_days');

var isAfter = require('date-fns/is_after');

var Document = require('../Document');

var log = require('../log');

var BankAccount = require('./BankAccount');

var _require = require('./matching-transactions'),
    matchTransactions = _require.matchTransactions;

var maxValue = function maxValue(iterable, fn) {
  var res = maxBy(iterable, fn);
  return res ? fn(res) : null;
};

var getDate = function getDate(transaction) {
  var date = transaction.realisationDate || transaction.date;
  return date.slice(0, 10);
};
/**
 * Get the date of the latest transaction in an array.
 * Transactions in the future are ignored.
 *
 * @param {array} stackTransactions
 * @returns {string} The date of the latest transaction (YYYY-MM-DD)
 */


var getSplitDate = function getSplitDate(stackTransactions) {
  var now = new Date();
  var notFutureTransactions = stackTransactions.filter(function (transaction) {
    var date = getDate(transaction);
    return !isAfter(date, now);
  });
  return maxValue(notFutureTransactions, getDate);
};

var ensureISOString = function ensureISOString(date) {
  if (date instanceof Date) {
    return date.toISOString();
  } else {
    return date;
  }
};

var Transaction =
/*#__PURE__*/
function (_Document) {
  (0, _inherits2.default)(Transaction, _Document);

  function Transaction() {
    (0, _classCallCheck2.default)(this, Transaction);
    return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(Transaction).apply(this, arguments));
  }

  (0, _createClass2.default)(Transaction, [{
    key: "isAfter",
    value: function isAfter(minDate) {
      if (!minDate) {
        return true;
      } else {
        var day = ensureISOString(this.date).slice(0, 10);

        if (day !== 'NaN') {
          return day > minDate;
        } else {
          log('warn', 'transaction date could not be parsed. transaction: ' + JSON.stringify(this));
          return false;
        }
      }
    }
  }, {
    key: "isBeforeOrSame",
    value: function isBeforeOrSame(maxDate) {
      if (!maxDate) {
        return true;
      } else {
        var day = ensureISOString(this.date).slice(0, 10);

        if (day !== 'NaN') {
          return day <= maxDate;
        } else {
          log('warn', 'transaction date could not be parsed. transaction: ' + JSON.stringify(this));
          return false;
        }
      }
    }
    /**
     * Get the descriptive (and almost uniq) identifier of a transaction
     * @param {object} transaction - The transaction (containing at least amount, originalBankLabel and date)
     * @returns {object}
     */

  }, {
    key: "getIdentifier",
    value: function getIdentifier() {
      return "".concat(this.amount, "-").concat(this.originalBankLabel, "-").concat(this.date);
    }
    /**
     * Get transactions that should be present in the stack but are not.
     * Transactions that are older that 1 week before the oldest existing
     * transaction are ignored.
     *
     * @param {array} newTransactions
     * @param {array} stackTransactions
     * @returns {array}
     */

  }, {
    key: "getVendorAccountId",
    value: function getVendorAccountId() {
      return this[this.constructor.vendorAccountIdAttr];
    }
  }], [{
    key: "getDate",
    value: function getDate(transaction) {
      return transaction;
    }
  }, {
    key: "getMissedTransactions",
    value: function getMissedTransactions(newTransactions, stackTransactions) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var oldestDate = maxValue(stackTransactions, getDate);
      var frontierDate = addDays(oldestDate, -7);
      var recentNewTransactions = newTransactions.filter(function (tr) {
        return isAfter(getDate(tr), frontierDate);
      });
      var matchingResults = Array.from(matchTransactions(recentNewTransactions, stackTransactions));
      var missedTransactions = matchingResults.filter(function (result) {
        return !result.match;
      }).map(function (result) {
        return result.transaction;
      });
      var trackEvent = options.trackEvent;

      if (typeof trackEvent === 'function') {
        try {
          var nbMissed = missedTransactions.length;
          var nbExisting = stackTransactions.length;
          trackEvent({
            e_a: 'ReconciliateMissing',
            e_n: 'MissedTransactionPct',
            e_v: parseFloat((nbMissed / nbExisting).toFixed(2), 10)
          });
          trackEvent({
            e_a: 'ReconciliateMissing',
            e_n: 'MissedTransactionAbs',
            e_v: nbMissed
          });
        } catch (e) {
          log('warn', "Could not send MissedTransaction event: ".concat(e.message));
        }
      }

      return missedTransactions;
    }
  }, {
    key: "reconciliate",
    value: function reconciliate(remoteTransactions, localTransactions) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      var findByVendorId = function findByVendorId(transaction) {
        return localTransactions.find(function (t) {
          return t.vendorId === transaction.vendorId;
        });
      };

      var groups = groupBy(remoteTransactions, function (transaction) {
        return findByVendorId(transaction) ? 'updatedTransactions' : 'newTransactions';
      });
      var newTransactions = groups.newTransactions || [];
      var updatedTransactions = groups.updatedTransactions || [];
      var splitDate = getSplitDate(localTransactions);

      if (splitDate) {
        if (typeof options.trackEvent === 'function') {
          options.trackEvent({
            e_a: 'ReconciliateSplitDate'
          });
        }

        var isAfterSplit = function isAfterSplit(x) {
          return Transaction.prototype.isAfter.call(x, splitDate);
        };

        var isBeforeSplit = function isBeforeSplit(x) {
          return Transaction.prototype.isBeforeOrSame.call(x, splitDate);
        };

        var transactionsAfterSplit = newTransactions.filter(isAfterSplit);

        if (transactionsAfterSplit.length > 0) {
          log('info', "Found ".concat(transactionsAfterSplit.length, " transactions after ").concat(splitDate));
        } else {
          log('info', "No transaction after ".concat(splitDate));
        }

        var transactionsBeforeSplit = newTransactions.filter(isBeforeSplit);
        log('info', "Found ".concat(transactionsBeforeSplit.length, " transactions before ").concat(splitDate));
        var missedTransactions = Transaction.getMissedTransactions(transactionsBeforeSplit, localTransactions, options);

        if (missedTransactions.length > 0) {
          log('info', "Found ".concat(missedTransactions.length, " missed transactions before ").concat(splitDate));
        } else {
          log('info', "No missed transactions before ".concat(splitDate));
        }

        newTransactions = [].concat((0, _toConsumableArray2.default)(transactionsAfterSplit), (0, _toConsumableArray2.default)(missedTransactions));
      } else {
        log('info', "Can't find a split date, saving all new transactions");
      }

      log('info', "Transaction reconciliation: new ".concat(newTransactions.length, ", updated ").concat(updatedTransactions.length, ", split date ").concat(splitDate, " "));
      return [].concat(newTransactions).concat(updatedTransactions);
    }
  }, {
    key: "getMostRecentForAccounts",
    value: function () {
      var _getMostRecentForAccounts = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee(accountIds) {
        var index, options, transactions;
        return _regenerator.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.prev = 0;
                log('debug', 'Transaction.getLast');
                _context.next = 4;
                return Document.getIndex(this.doctype, ['date', 'account']);

              case 4:
                index = _context.sent;
                options = {
                  selector: {
                    date: {
                      $gte: null
                    },
                    account: {
                      $in: accountIds
                    }
                  },
                  sort: [{
                    date: 'desc'
                  }]
                };
                _context.next = 8;
                return Document.query(index, options);

              case 8:
                transactions = _context.sent;
                log('info', 'last transactions length: ' + transactions.length);
                return _context.abrupt("return", transactions);

              case 13:
                _context.prev = 13;
                _context.t0 = _context["catch"](0);
                log('error', _context.t0);
                return _context.abrupt("return", []);

              case 17:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[0, 13]]);
      }));

      function getMostRecentForAccounts(_x) {
        return _getMostRecentForAccounts.apply(this, arguments);
      }

      return getMostRecentForAccounts;
    }()
  }, {
    key: "deleteOrphans",
    value: function () {
      var _deleteOrphans = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee2() {
        var accounts, operations, orphanOperations;
        return _regenerator.default.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                log('info', 'Deleting up orphan operations');
                _context2.t0 = keyBy;
                _context2.next = 4;
                return BankAccount.fetchAll();

              case 4:
                _context2.t1 = _context2.sent;
                accounts = (0, _context2.t0)(_context2.t1, '_id');
                _context2.next = 8;
                return this.fetchAll();

              case 8:
                operations = _context2.sent;
                orphanOperations = operations.filter(function (x) {
                  return !accounts[x.account];
                });
                log('info', "Total number of operations: ".concat(operations.length));
                log('info', "Total number of orphan operations: ".concat(orphanOperations.length));
                log('info', "Deleting ".concat(orphanOperations.length, " orphan operations..."));

                if (!(orphanOperations.length > 0)) {
                  _context2.next = 15;
                  break;
                }

                return _context2.abrupt("return", this.deleteAll(orphanOperations));

              case 15:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function deleteOrphans() {
        return _deleteOrphans.apply(this, arguments);
      }

      return deleteOrphans;
    }()
  }, {
    key: "getCategoryId",
    value: function getCategoryId(transaction, options) {
      var opts = (0, _objectSpread2.default)({
        localModelOverride: false,
        localModelUsageThreshold: this.LOCAL_MODEL_USAGE_THRESHOLD,
        globalModelUsageThreshold: this.GLOBAL_MODEL_USAGE_THRESHOLD
      }, options);

      if (transaction.manualCategoryId) {
        return transaction.manualCategoryId;
      }

      if (opts.localModelOverride && transaction.localCategoryId && transaction.localCategoryProba && transaction.localCategoryProba > opts.localModelUsageThreshold) {
        return transaction.localCategoryId;
      }

      if (transaction.cozyCategoryId && transaction.cozyCategoryProba && transaction.cozyCategoryProba > opts.globalModelUsageThreshold) {
        return transaction.cozyCategoryId;
      } // If the cozy categorization models have not been applied, we return null
      // so the transaction is considered as « categorization in progress ».
      // Otherwize we just use the automatic categorization from the vendor


      if (!transaction.localCategoryId && !transaction.cozyCategoryId) {
        return null;
      }

      return transaction.automaticCategoryId;
    }
  }]);
  return Transaction;
}(Document);

Transaction.doctype = 'io.cozy.bank.operations';
Transaction.version = 1;
Transaction.vendorAccountIdAttr = 'vendorAccountId';
Transaction.vendorIdAttr = 'vendorId';
Transaction.idAttributes = ['vendorId'];
Transaction.checkedAttributes = ['label', 'originalBankLabel', 'automaticCategoryId', 'account'];
Transaction.LOCAL_MODEL_USAGE_THRESHOLD = 0.8;
Transaction.GLOBAL_MODEL_USAGE_THRESHOLD = 0.15;
Transaction.getSplitDate = getSplitDate;
module.exports = Transaction;