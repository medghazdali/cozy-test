"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getQueryFromSlice = exports.receiveQueryError = exports.receiveQueryResult = exports.loadQuery = exports.initQuery = exports.default = exports.makeSorterFromDefinition = exports.convert$gtNullSelectors = exports.isReceivingData = exports.isQueryAction = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _objectSpread3 = _interopRequireDefault(require("@babel/runtime/helpers/objectSpread"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _mapValues = _interopRequireDefault(require("lodash/mapValues"));

var _difference = _interopRequireDefault(require("lodash/difference"));

var _intersection = _interopRequireDefault(require("lodash/intersection"));

var _concat = _interopRequireDefault(require("lodash/concat"));

var _isPlainObject = _interopRequireDefault(require("lodash/isPlainObject"));

var _uniq = _interopRequireDefault(require("lodash/uniq"));

var _orderBy = _interopRequireDefault(require("lodash/orderBy"));

var _isArray = _interopRequireDefault(require("lodash/isArray"));

var _isString = _interopRequireDefault(require("lodash/isString"));

var _documents = require("./documents");

var _mutations = require("./mutations");

var _helpers = require("./helpers");

var _sift = _interopRequireDefault(require("sift"));

var _get = _interopRequireDefault(require("lodash/get"));

var INIT_QUERY = 'INIT_QUERY';
var LOAD_QUERY = 'LOAD_QUERY';
var RECEIVE_QUERY_RESULT = 'RECEIVE_QUERY_RESULT';
var RECEIVE_QUERY_ERROR = 'RECEIVE_QUERY_ERROR';

var isQueryAction = function isQueryAction(action) {
  return [INIT_QUERY, RECEIVE_QUERY_RESULT, RECEIVE_QUERY_ERROR].indexOf(action.type) !== -1;
};

exports.isQueryAction = isQueryAction;

var isReceivingData = function isReceivingData(action) {
  return action.type === RECEIVE_QUERY_RESULT;
}; // reducers


exports.isReceivingData = isReceivingData;
var queryInitialState = {
  id: null,
  definition: null,
  fetchStatus: 'pending',
  lastFetch: null,
  lastUpdate: null,
  lastError: null,
  hasMore: false,
  count: 0,
  data: [],
  bookmark: null
};

var updateQueryDataFromResponse = function updateQueryDataFromResponse(queryState, response, nextDocuments) {
  var updatedIds = (0, _uniq.default)([].concat((0, _toConsumableArray2.default)(queryState.data), (0, _toConsumableArray2.default)(response.data.map(_helpers.properId))));

  if (queryState.definition.sort) {
    var sorter = makeSorterFromDefinition(queryState.definition);
    var doctype = queryState.definition.doctype;
    var allDocs = nextDocuments[doctype];
    var docs = updatedIds.map(function (_id) {
      return allDocs[_id];
    });
    var sortedDocs = sorter(docs);
    updatedIds = sortedDocs.map(_helpers.properId);
  }

  return updatedIds;
};

var query = function query() {
  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : queryInitialState;
  var action = arguments.length > 1 ? arguments[1] : undefined;
  var nextDocuments = arguments.length > 2 ? arguments[2] : undefined;

  switch (action.type) {
    case INIT_QUERY:
      if (state.lastUpdate && state.id === action.queryId && state.definition === action.queryDefinition) {
        return state;
      }

      return (0, _objectSpread3.default)({}, state, {
        id: action.queryId,
        definition: action.queryDefinition,
        // When the query is new, we set "fetchStatus" to "loading"
        // directly since we know it will be loaded right away.
        // This way, the loadQuery action will have no effect, and
        // we save an additional render.
        fetchStatus: state.lastUpdate ? state.fetchStatus : 'loading'
      });

    case LOAD_QUERY:
      if (state.fetchStatus === 'loading') {
        return state;
      }

      return (0, _objectSpread3.default)({}, state, {
        fetchStatus: 'loading'
      });

    case RECEIVE_QUERY_RESULT:
      {
        var response = action.response;
        var common = {
          fetchStatus: 'loaded',
          lastFetch: Date.now(),
          lastUpdate: Date.now()
        };

        if (!response.data) {
          return state;
        }

        if (!Array.isArray(response.data)) {
          return (0, _objectSpread3.default)({}, state, common, {
            hasMore: false,
            count: 1,
            data: [(0, _helpers.properId)(response.data)]
          });
        }

        return (0, _objectSpread3.default)({}, state, common, {
          bookmark: response.bookmark || null,
          hasMore: response.next !== undefined ? response.next : state.hasMore,
          count: response.meta && response.meta.count ? response.meta.count : response.data.length,
          data: updateQueryDataFromResponse(state, response, nextDocuments)
        });
      }

    case RECEIVE_QUERY_ERROR:
      return (0, _objectSpread3.default)({}, state, {
        id: action.queryId,
        fetchStatus: 'failed',
        lastError: action.error
      });

    default:
      return state;
  }
};

var convert$gtNullSelectors = function convert$gtNullSelectors(selector) {
  var result = {};

  for (var _i = 0, _Object$entries = Object.entries(selector); _i < _Object$entries.length; _i++) {
    var _Object$entries$_i = (0, _slicedToArray2.default)(_Object$entries[_i], 2),
        key = _Object$entries$_i[0],
        value = _Object$entries$_i[1];

    var convertedValue = (0, _isPlainObject.default)(value) ? convert$gtNullSelectors(value) : value;
    var convertedKey = key === '$gt' && convertedValue === null ? '$gtnull' : key;
    result[convertedKey] = convertedValue;
  }

  return result;
};

exports.convert$gtNullSelectors = convert$gtNullSelectors;

var getSelectorFilterFn = function getSelectorFilterFn(queryDefinition) {
  if (queryDefinition.selector) {
    // sift does not work like couchdb when using { $gt: null } as a selector, so we use a custom operator
    _sift.default.use({
      $gtnull: function $gtnull(selectorValue, actualValue) {
        return !!actualValue;
      }
    });

    return (0, _sift.default)(convert$gtNullSelectors(queryDefinition.selector));
  } else if (queryDefinition.id) {
    return (0, _sift.default)({
      _id: queryDefinition.id
    });
  } else if (queryDefinition.ids) {
    return (0, _sift.default)({
      _id: {
        $in: queryDefinition.ids
      }
    });
  } else {
    return null;
  }
};

var getQueryDocumentsChecker = function getQueryDocumentsChecker(query) {
  var qdoctype = query.definition.doctype;
  var selectorFilterFn = getSelectorFilterFn(query.definition);
  return function (datum) {
    var ddoctype = datum._type;
    if (ddoctype !== qdoctype) return false;

    if (selectorFilterFn && !selectorFilterFn(datum)) {
      return false;
    }

    if (datum._deleted) return false;
    return true;
  };
};

var makeCaseInsensitiveStringSorter = function makeCaseInsensitiveStringSorter(attrName) {
  return function (item) {
    var attrValue = (0, _get.default)(item, attrName);
    return (0, _isString.default)(attrValue) ? attrValue.toLowerCase() : attrValue;
  };
};
/**
 * Creates a sort function from a definition.
 *
 * Used to sort query results inside the store when creating a file or
 * receiving updates.
 *
 * @private
 */


var makeSorterFromDefinition = function makeSorterFromDefinition(definition) {
  var sort = definition.sort;

  if (!sort) {
    return function (docs) {
      return docs;
    };
  } else if (!(0, _isArray.default)(definition.sort)) {
    console.warn('Correct update of queries with a sort that is not an array is not supported. Use an array as argument of QueryDefinition::sort');
    return function (docs) {
      return docs;
    };
  } else {
    var attributeOrders = sort.map(function (x) {
      return Object.entries(x)[0];
    });
    var attrs = attributeOrders.map(function (x) {
      return x[0];
    }).map(makeCaseInsensitiveStringSorter);
    var orders = attributeOrders.map(function (x) {
      return x[1];
    });
    return function (docs) {
      return (0, _orderBy.default)(docs, attrs, orders);
    };
  }
};

exports.makeSorterFromDefinition = makeSorterFromDefinition;

var updateData = function updateData(query, newData, nextDocuments) {
  var isFulfilled = getQueryDocumentsChecker(query);
  var matchedIds = newData.filter(function (doc) {
    return isFulfilled(doc);
  }).map(_helpers.properId);
  var unmatchedIds = newData.filter(function (doc) {
    return !isFulfilled(doc);
  }).map(_helpers.properId);
  var originalIds = query.data;
  var toRemove = (0, _intersection.default)(originalIds, unmatchedIds);
  var toAdd = (0, _difference.default)(matchedIds, originalIds);
  var toUpdate = (0, _intersection.default)(originalIds, matchedIds);
  var changed = toRemove.length || toAdd.length || toUpdate.length; // concat doesn't check duplicates (contrarily to union), which is ok as
  // toAdd does not contain any id present in originalIds, by construction.
  // It is also faster than union.

  var updatedData = (0, _difference.default)((0, _concat.default)(originalIds, toAdd), toRemove);

  if (query.definition.sort && nextDocuments) {
    var sorter = makeSorterFromDefinition(query.definition);
    var allDocs = nextDocuments[query.definition.doctype];
    var docs = updatedData.map(function (_id) {
      return allDocs[_id];
    });
    var sortedDocs = sorter(docs);
    updatedData = sortedDocs.map(_helpers.properId);
  }

  return (0, _objectSpread3.default)({}, query, {
    data: updatedData,
    count: updatedData.length,
    lastUpdate: changed ? Date.now() : query.lastUpdate
  });
};

var autoQueryUpdater = function autoQueryUpdater(action, nextDocuments) {
  return function (query) {
    var data = (0, _get.default)(action, 'response.data') || (0, _get.default)(action, 'definition.document');
    if (!data) return query;

    if (!Array.isArray(data)) {
      data = [data];
    }

    if (!data.length) {
      return query;
    }

    if (query.definition.doctype !== data[0]._type) {
      return query;
    }

    return updateData(query, data, nextDocuments);
  };
};

var manualQueryUpdater = function manualQueryUpdater(action, documents) {
  return function (query) {
    var updateQueries = action.updateQueries;
    var response = action.response;
    var updater = updateQueries[query.id];

    if (!updater) {
      return query;
    }

    var doctype = query.definition.doctype;
    var oldData = query.data;
    var oldDocs = mapIdsToDocuments(documents, doctype, oldData);
    var newData = updater(oldDocs, response);
    var newDataIds = newData.map(_helpers.properId);
    return (0, _objectSpread3.default)({}, query, {
      data: newDataIds,
      count: newDataIds.length,
      lastUpdate: Date.now()
    });
  };
};

var queries = function queries() {
  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var action = arguments.length > 1 ? arguments[1] : undefined;
  var nextDocuments = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var haveDocumentsChanged = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;

  if (action.type == INIT_QUERY) {
    var newQueryState = query(state[action.queryId], action); // Do not create new object unnecessarily

    if (newQueryState === state[action.queryId]) {
      return state;
    }

    return (0, _objectSpread3.default)({}, state, (0, _defineProperty2.default)({}, action.queryId, newQueryState));
  }

  if (isQueryAction(action)) {
    var updater = autoQueryUpdater(action, nextDocuments);
    return (0, _mapValues.default)(state, function (queryState) {
      if (queryState.id == action.queryId) {
        return query(queryState, action, nextDocuments);
      } else if (haveDocumentsChanged) {
        return updater(queryState);
      } else {
        return queryState;
      }
    });
  }

  if ((0, _mutations.isReceivingMutationResult)(action)) {
    var _updater = action.updateQueries ? manualQueryUpdater(action, nextDocuments) : autoQueryUpdater(action, nextDocuments);

    return (0, _mapValues.default)(state, _updater);
  }

  return state;
};

var _default = queries; // actions

exports.default = _default;

var initQuery = function initQuery(queryId, queryDefinition) {
  if (!queryDefinition.doctype) {
    throw new Error('Cannot init query with no doctype');
  }

  return {
    type: INIT_QUERY,
    queryId: queryId,
    queryDefinition: queryDefinition
  };
};

exports.initQuery = initQuery;

var loadQuery = function loadQuery(queryId) {
  return {
    type: LOAD_QUERY,
    queryId: queryId
  };
};

exports.loadQuery = loadQuery;

var receiveQueryResult = function receiveQueryResult(queryId, response) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  return (0, _objectSpread3.default)({
    type: RECEIVE_QUERY_RESULT,
    queryId: queryId,
    response: response
  }, options);
};

exports.receiveQueryResult = receiveQueryResult;

var receiveQueryError = function receiveQueryError(queryId, error) {
  return {
    type: RECEIVE_QUERY_ERROR,
    queryId: queryId,
    error: error
  };
}; // selectors


exports.receiveQueryError = receiveQueryError;

var mapIdsToDocuments = function mapIdsToDocuments(documents, doctype, ids) {
  return ids.map(function (id) {
    return (0, _documents.getDocumentFromSlice)(documents, doctype, id);
  });
};

var getQueryFromSlice = function getQueryFromSlice(state, queryId, documents) {
  if (!state || !state[queryId]) {
    return (0, _objectSpread3.default)({}, queryInitialState, {
      data: null
    });
  }

  var query = state[queryId];
  return documents ? (0, _objectSpread3.default)({}, query, {
    data: mapIdsToDocuments(documents, query.definition.doctype, query.data)
  }) : query;
};

exports.getQueryFromSlice = getQueryFromSlice;