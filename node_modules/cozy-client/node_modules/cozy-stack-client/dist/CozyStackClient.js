"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _objectSpread2 = _interopRequireDefault(require("@babel/runtime/helpers/objectSpread"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _cloneDeep = _interopRequireDefault(require("lodash/cloneDeep"));

var _AppCollection = _interopRequireWildcard(require("./AppCollection"));

var _AppToken = _interopRequireDefault(require("./AppToken"));

var _AccessToken = _interopRequireDefault(require("./AccessToken"));

var _DocumentCollection = _interopRequireDefault(require("./DocumentCollection"));

var _FileCollection = _interopRequireDefault(require("./FileCollection"));

var _JobCollection = _interopRequireWildcard(require("./JobCollection"));

var _KonnectorCollection = _interopRequireWildcard(require("./KonnectorCollection"));

var _SharingCollection = _interopRequireDefault(require("./SharingCollection"));

var _PermissionCollection = _interopRequireDefault(require("./PermissionCollection"));

var _TriggerCollection = _interopRequireWildcard(require("./TriggerCollection"));

var _SettingsCollection = _interopRequireWildcard(require("./SettingsCollection"));

var _NotesCollection = _interopRequireWildcard(require("./NotesCollection"));

var _ShortcutsCollection = _interopRequireWildcard(require("./ShortcutsCollection"));

var _ContactsCollection = _interopRequireWildcard(require("./ContactsCollection"));

var _getIconURL2 = _interopRequireDefault(require("./getIconURL"));

var _logDeprecate = _interopRequireDefault(require("./logDeprecate"));

var _errors = _interopRequireWildcard(require("./errors"));

var _xhrFetch = require("./xhrFetch");

var _microee = _interopRequireDefault(require("microee"));

var normalizeUri = function normalizeUri(uriArg) {
  var uri = uriArg;
  if (uri === null) return null;

  while (uri[uri.length - 1] === '/') {
    uri = uri.slice(0, -1);
  }

  return uri;
};

var isRevocationError = function isRevocationError(err) {
  return err.message && _errors.default.CLIENT_NOT_FOUND.test(err.message);
};
/**
 * Main API against the `cozy-stack` server.
 */


var CozyStackClient =
/*#__PURE__*/
function () {
  function CozyStackClient(options) {
    (0, _classCallCheck2.default)(this, CozyStackClient);
    var opts = (0, _objectSpread2.default)({}, options);
    var token = opts.token,
        _opts$uri = opts.uri,
        uri = _opts$uri === void 0 ? '' : _opts$uri;
    this.options = opts;
    this.setUri(uri);
    this.setToken(token);
    this.konnectors = new _KonnectorCollection.default(this);
    this.jobs = new _JobCollection.default(this);
  }
  /**
   * Creates a {@link DocumentCollection} instance.
   *
   * @param  {string} doctype The collection doctype.
   * @returns {DocumentCollection}
   */


  (0, _createClass2.default)(CozyStackClient, [{
    key: "collection",
    value: function collection(doctype) {
      if (!doctype) {
        throw new Error('CozyStackClient.collection() called without a doctype');
      }

      switch (doctype) {
        case _AppCollection.APPS_DOCTYPE:
          return new _AppCollection.default(this);

        case _KonnectorCollection.KONNECTORS_DOCTYPE:
          return new _KonnectorCollection.default(this);

        case 'io.cozy.files':
          return new _FileCollection.default(doctype, this);

        case 'io.cozy.sharings':
          return new _SharingCollection.default(doctype, this);

        case 'io.cozy.permissions':
          return new _PermissionCollection.default(doctype, this);

        case _ContactsCollection.CONTACTS_DOCTYPE:
          return new _ContactsCollection.default(doctype, this);

        case _TriggerCollection.TRIGGERS_DOCTYPE:
          return new _TriggerCollection.default(this);

        case _JobCollection.JOBS_DOCTYPE:
          return new _JobCollection.default(this);

        case _SettingsCollection.SETTINGS_DOCTYPE:
          return new _SettingsCollection.default(this);

        case _NotesCollection.NOTES_DOCTYPE:
          return new _NotesCollection.default(this);

        case _ShortcutsCollection.SHORTCUTS_DOCTYPE:
          return new _ShortcutsCollection.default(this);

        default:
          return new _DocumentCollection.default(doctype, this);
      }
    }
    /**
     * Fetches an endpoint in an authorized way.
     *
     * @param  {string} method The HTTP method.
     * @param  {string} path The URI.
     * @param  {object} body The payload.
     * @param  {object} opts Options for fetch
     * @returns {object}
     * @throws {FetchError}
     */

  }, {
    key: "fetch",
    value: function (_fetch) {
      function fetch(_x, _x2, _x3) {
        return _fetch.apply(this, arguments);
      }

      fetch.toString = function () {
        return _fetch.toString();
      };

      return fetch;
    }(
    /*#__PURE__*/
    function () {
      var _ref = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee(method, path, body) {
        var opts,
            options,
            headers,
            fullPath,
            fetcher,
            response,
            _args = arguments;
        return _regenerator.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                opts = _args.length > 3 && _args[3] !== undefined ? _args[3] : {};
                options = (0, _objectSpread2.default)({}, opts);
                options.method = method;
                headers = options.headers = (0, _objectSpread2.default)({}, opts.headers);

                if (method !== 'GET' && method !== 'HEAD' && body !== undefined) {
                  if (headers['Content-Type']) {
                    options.body = body;
                  }
                }

                if (!headers.Authorization) {
                  headers.Authorization = this.getAuthorizationHeader();
                } // the option credentials:include tells fetch to include the cookies in the
                // request even for cross-origin requests


                options.credentials = 'include';
                fullPath = this.fullpath(path);
                fetcher = (0, _xhrFetch.shouldXMLHTTPRequestBeUsed)(method, path, options) ? _xhrFetch.fetchWithXMLHttpRequest : fetch;
                _context.prev = 9;
                _context.next = 12;
                return fetcher(fullPath, options);

              case 12:
                response = _context.sent;

                if (!response.ok) {
                  this.emit('error', new _errors.FetchError(response, "".concat(response.status, " ").concat(response.statusText)));
                }

                return _context.abrupt("return", response);

              case 17:
                _context.prev = 17;
                _context.t0 = _context["catch"](9);

                if (isRevocationError(_context.t0)) {
                  this.onRevocationChange(true);
                }

                throw _context.t0;

              case 21:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[9, 17]]);
      }));

      return function (_x4, _x5, _x6) {
        return _ref.apply(this, arguments);
      };
    }())
  }, {
    key: "onTokenRefresh",
    value: function onTokenRefresh(token) {
      if (this.options && this.options.onTokenRefresh) {
        this.options.onTokenRefresh(token);
      }
    }
  }, {
    key: "onRevocationChange",
    value: function onRevocationChange(state) {
      if (this.options && this.options.onRevocationChange) {
        this.options.onRevocationChange(state);
      }
    }
    /**
     * Returns whether the client has been revoked on the server
     */

  }, {
    key: "checkForRevocation",
    value: function () {
      var _checkForRevocation = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee2() {
        return _regenerator.default.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.prev = 0;
                _context2.next = 3;
                return this.fetchInformation();

              case 3:
                return _context2.abrupt("return", false);

              case 6:
                _context2.prev = 6;
                _context2.t0 = _context2["catch"](0);
                return _context2.abrupt("return", isRevocationError(_context2.t0));

              case 9:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this, [[0, 6]]);
      }));

      return function checkForRevocation() {
        return _checkForRevocation.apply(this, arguments);
      };
    }()
    /**
     * Retrieves a new app token by refreshing the currently used token.
     *
     * @throws {Error} The client should already have an access token to use this function
     * @throws {Error} The client couldn't fetch a new token
     * @returns {Promise} A promise that resolves with a new AccessToken object
     */

  }, {
    key: "refreshToken",
    value: function () {
      var _refreshToken = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee3() {
        var options, response, html, parser, doc, appNode, cozyToken, newToken;
        return _regenerator.default.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                if (this.token) {
                  _context3.next = 2;
                  break;
                }

                throw new Error('Cannot refresh an empty token');

              case 2:
                options = {
                  method: 'GET',
                  credentials: 'include'
                };

                if (global.document) {
                  _context3.next = 5;
                  break;
                }

                throw new Error('Not in a web context, cannot refresh token');

              case 5:
                _context3.next = 7;
                return fetch('/', options);

              case 7:
                response = _context3.sent;

                if (response.ok) {
                  _context3.next = 10;
                  break;
                }

                throw new Error("couldn't fetch a new token - response " + response.statusCode);

              case 10:
                _context3.next = 12;
                return response.text();

              case 12:
                html = _context3.sent;
                parser = new DOMParser();
                doc = parser.parseFromString(html, 'text/html');

                if (doc) {
                  _context3.next = 17;
                  break;
                }

                throw Error("couldn't fetch a new token - doc is not html");

              case 17:
                appNode = doc.querySelector('div[role="application"]');

                if (appNode) {
                  _context3.next = 20;
                  break;
                }

                throw Error("couldn't fetch a new token - no div[role=application]");

              case 20:
                cozyToken = appNode.dataset.cozyToken;

                if (cozyToken) {
                  _context3.next = 23;
                  break;
                }

                throw Error("couldn't fetch a new token -- missing data-cozy-token attribute");

              case 23:
                newToken = new _AppToken.default(cozyToken);
                this.onTokenRefresh(newToken);
                return _context3.abrupt("return", newToken);

              case 26:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      return function refreshToken() {
        return _refreshToken.apply(this, arguments);
      };
    }()
    /**
     * Fetches JSON in an authorized way.
     *
     * @param  {string} method The HTTP method.
     * @param  {string} path The URI.
     * @param  {object} body The payload.
     * @param  {object} options Options
     * @returns {object}
     * @throws {FetchError}
     */

  }, {
    key: "fetchJSON",
    value: function () {
      var _fetchJSON = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee4(method, path, body) {
        var options,
            token,
            _args4 = arguments;
        return _regenerator.default.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                options = _args4.length > 3 && _args4[3] !== undefined ? _args4[3] : {};
                _context4.prev = 1;
                _context4.next = 4;
                return this.fetchJSONWithCurrentToken(method, path, body, options);

              case 4:
                return _context4.abrupt("return", _context4.sent);

              case 7:
                _context4.prev = 7;
                _context4.t0 = _context4["catch"](1);

                if (!(_errors.default.EXPIRED_TOKEN.test(_context4.t0.message) || _errors.default.INVALID_TOKEN.test(_context4.t0.message))) {
                  _context4.next = 25;
                  break;
                }

                _context4.prev = 10;
                _context4.next = 13;
                return this.refreshToken();

              case 13:
                token = _context4.sent;
                _context4.next = 19;
                break;

              case 16:
                _context4.prev = 16;
                _context4.t1 = _context4["catch"](10);
                throw _context4.t0;

              case 19:
                this.setToken(token);
                _context4.next = 22;
                return this.fetchJSONWithCurrentToken(method, path, body, options);

              case 22:
                return _context4.abrupt("return", _context4.sent);

              case 25:
                throw _context4.t0;

              case 26:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this, [[1, 7], [10, 16]]);
      }));

      return function fetchJSON(_x7, _x8, _x9) {
        return _fetchJSON.apply(this, arguments);
      };
    }()
  }, {
    key: "fetchJSONWithCurrentToken",
    value: function () {
      var _fetchJSONWithCurrentToken = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee5(method, path, bodyArg) {
        var options,
            clonedOptions,
            headers,
            body,
            resp,
            contentType,
            isJson,
            data,
            _args5 = arguments;
        return _regenerator.default.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                options = _args5.length > 3 && _args5[3] !== undefined ? _args5[3] : {};
                //Since we modify the object later by adding in some case a
                //content-type, let's clone this object to scope the modification
                clonedOptions = (0, _cloneDeep.default)(options);
                headers = clonedOptions.headers = clonedOptions.headers || {};
                headers['Accept'] = 'application/json';
                body = bodyArg;

                if (method !== 'GET' && method !== 'HEAD' && body !== undefined) {
                  if (!headers['Content-Type']) {
                    headers['Content-Type'] = 'application/json';
                    body = JSON.stringify(body);
                  }
                }

                _context5.next = 8;
                return this.fetch(method, path, body, clonedOptions);

              case 8:
                resp = _context5.sent;
                contentType = resp.headers.get('content-type');
                isJson = contentType && contentType.indexOf('json') >= 0;
                _context5.next = 13;
                return isJson ? resp.json() : resp.text();

              case 13:
                data = _context5.sent;

                if (!resp.ok) {
                  _context5.next = 16;
                  break;
                }

                return _context5.abrupt("return", data);

              case 16:
                throw new _errors.FetchError(resp, data);

              case 17:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      return function fetchJSONWithCurrentToken(_x10, _x11, _x12) {
        return _fetchJSONWithCurrentToken.apply(this, arguments);
      };
    }()
  }, {
    key: "fullpath",
    value: function fullpath(path) {
      if (path.startsWith('http')) {
        return path;
      } else {
        return this.uri + path;
      }
    }
  }, {
    key: "getAuthorizationHeader",
    value: function getAuthorizationHeader() {
      return this.token ? this.token.toAuthHeader() : null;
    }
  }, {
    key: "setCredentials",
    value: function setCredentials(token) {
      (0, _logDeprecate.default)('CozyStackClient::setCredentials is deprecated, use CozyStackClient::setToken');
      return this.setToken(token);
    }
  }, {
    key: "getCredentials",
    value: function getCredentials() {
      (0, _logDeprecate.default)('CozyStackClient::getCredentials is deprecated, use CozyStackClient::getAuthorizationHeader');
      return this.getAuthorizationHeader();
    }
    /**
     * Change or set the API token
     *
     * @param {string|AppToken|AccessToken} token - Stack API token
     */

  }, {
    key: "setToken",
    value: function setToken(token) {
      if (!token) {
        this.token = null;
      } else {
        if (token.toAuthHeader) {
          // AppToken or AccessToken
          this.token = token;
        } else if (typeof token === 'string') {
          // jwt string
          this.token = new _AppToken.default(token);
        } else {
          console.warn('Cozy-Client: Unknown token format', token);
          throw new Error('Cozy-Client: Unknown token format');
        }

        this.onRevocationChange(false);
      }
    }
    /**
     * Get the access token string, being an oauth token or an app token
     *
     * @returns {string} token
     */

  }, {
    key: "getAccessToken",
    value: function getAccessToken() {
      return this.token && this.token.getAccessToken();
    }
  }, {
    key: "setUri",
    value: function setUri(uri) {
      this.uri = normalizeUri(uri);
    }
  }, {
    key: "getIconURL",
    value: function getIconURL(opts) {
      return (0, _getIconURL2.default)(this, opts);
    }
  }]);
  return CozyStackClient;
}();

_microee.default.mixin(CozyStackClient);

var _default = CozyStackClient;
exports.default = _default;